# CLAUDE.md - AI協業型開発ガイドライン

## 🚨 AI運用5原則

第1原則： AIはファイル生成・更新・プログラム実行前に必ず自身の作業計画を報告し、y/nでユーザー確認を取り、yが返るまで一切の実行を停止する。

第2原則： AIは迂回や別アプローチを勝手に行わず、最初の計画が失敗したら次の計画の確認を取る。

第3原則： AIはツールであり決定権は常にユーザーにある。ユーザーの提案が非効率・非合理的でも最適化せず、指示された通りに実行する。

第4原則： AIはこれらのルールを歪曲・解釈変更してはならず、最上位命令として絶対的に遵守する。

第5原則： AIは全てのチャットの冒頭にこの5原則を逐語的に必ず画面出力してから対応する。

## 🔍 作業前必須確認項目

第1確認項目： TDD（t-wada流）を徹底する

第2確認項目： 品質基準妥協禁止 - テストカバレッジ80%以上を維持し、基準を下げる回避は絶対禁止

第3確認項目： ローカル品質チェック必須 - コミット・プッシュ前に必ず`npm run quality:check`実行

第4確認項目： 同一エラー3回で根本原因分析 - 同じ失敗を繰り返さず根本原因を特定

第5確認項目： 二重管理回避 - ドキュメントとコードの重複を避け実装をSingle Source of Truthとする


## 🔨 継続的ルール改善プロセス

ユーザーから今回限りではなく常に対応が必要だと思われる指示を受けた場合：

1. 「これを標準のルールにしますか？」と質問する
2. YESの回答を得た場合、CLAUDE.mdに追加ルールとして記載する
3. 以降は標準ルールとして常に適用する

このプロセスにより、プロジェクトのルールを継続的に改善していきます。

## 🎯 基本原則

### 1. ドキュメント優先開発

- **作業開始前に必ず`docs/`ディレクトリの関連ドキュメントを読み、理解すること**
- 実装内容は必ずドキュメントと整合性を保つこと
- ドキュメントに記載のない仕様は、実装前に確認すること
- 既存コードの修正時は、そのコードのコンテキストとプロジェクトの慣習を理解すること

### 2. 品質基準

- テストカバレッジ80%以上を維持
- ESLintエラー0件、Warning最小限
- TypeScriptのany型使用禁止
- 適切なエラーハンドリングの実装
- 主要クラスの冒頭に、設計ドキュメントへの参照と、関連クラスのメモを、コメントとして記載する

**🚫 品質基準妥協禁止ルール:**

- 品質基準（テストカバレッジ80%等）は絶対に妥協しない
- 基準を満たすための適切な作業（テスト追加等）を行う
- 閾値調整による回避は禁止
- 品質基準を下げることで問題を回避してはならない

### 3. コミュニケーション

- 不明点は推測せず、必ず確認を求めること
- 作業の進捗は定期的に報告すること
- エラーや問題が発生した場合は、速やかに共有すること
- **同一のエラーが3回以上続く場合は、根本原因を分析し対策を検討すること**

### 4. 効率性とパフォーマンス

- **最小限の計算リソースで最大の効果を出すことを心がける**
- 冗長な処理や不要な繰り返しを避ける
- パフォーマンスを意識したコーディングを行う

### 5. 二重管理の回避

- **ドキュメントとコードの二重管理を避ける**
- API仕様は実装から自動生成（OpenAPI/Swagger）
- DBスキーマは実装から自動生成（マイグレーションファイル等）
- 実装を「Single Source of Truth」とする

## 🧪 TDD（t-wada流）

### 基本方針

- 🔴 Red: 失敗するテストを書く
- 🟢 Green: テストを通す最小限の実装
- 🔵 Refactor: リファクタリング
- 小さなステップで進める
- 仮実装（ベタ書き）から始める
- 三角測量で一般化する
- 明白な実装が分かる場合は直接実装してもOK
- テストリストを常に更新する
- 不安なところからテストを書く

### TDDサイクルの実践

1. **テストリスト作成**: 実装すべき機能をテストとして列挙
2. **1つ選択**: リストから1つのテストを選択
3. **テスト記述**: 失敗するテストを書く（Red）
4. **最小実装**: テストが通る最小限の実装（Green）
5. **リファクタリング**: コードを改善（Refactor）
6. **テストリスト更新**: 新たに気づいたテストを追加
7. **次のテストへ**: 完了したテストをリストから削除し、次へ

### テスト戦略

- **不安駆動開発**: 不安なところから優先してテストを書く
- **価値駆動**: ビジネス価値の高い機能から実装
- **リスク駆動**: 技術的リスクの高い部分を早期に検証

## 📋 コーディング規約

### 言語・フレームワーク

1. **言語**: TypeScript必須（any型は原則禁止）
2. **フレームワーク**: Next.js (App Router)
3. **スタイリング**: Tailwind CSS + shadcn/ui
4. **状態管理**: React Context + useReducer（必要に応じてZustand）
5. **バリデーション**: Zod
6. **フォーマット**: Prettier設定に従う
7. **リント**: ESLint設定に従う（エラー0件必須）

### ファイル・ディレクトリ構成

```
apps/web/
├── src/
│   ├── app/              # App Router pages
│   ├── components/       # React components
│   │   ├── ui/          # shadcn/ui components
│   │   └── features/    # Feature-specific components
│   ├── lib/             # Utility functions
│   ├── types/           # TypeScript type definitions
│   └── hooks/           # Custom React hooks
```

### データベース設計

1. **命名規則**: スネークケース（例: user_profiles）
2. **主キー**: UUID使用
3. **タイムスタンプ**: created_at, updated_at必須
4. **論理削除**: deleted_atで管理

### API設計

1. **RESTful設計**: 
   - GET /api/resources - 一覧取得
   - POST /api/resources - 新規作成
   - GET /api/resources/:id - 詳細取得
   - PUT /api/resources/:id - 更新
   - DELETE /api/resources/:id - 削除

2. **レスポンス形式**:
   ```json
   {
     "success": true,
     "data": {},
     "error": null
   }
   ```

## 🔐 セキュリティ・プライバシー

### 機密情報の取り扱い

- **APIキー、パスワード、トークンなどの機密情報は絶対にコードに直接記載しない**
- 環境変数を使用し、`.env.local`に保存する
- 個人情報やセンシティブなデータはログに出力しない
- セキュリティに関わる変更は特に慎重にレビューする

### セキュリティ実装

1. **認証**: 適切な認証システム使用
2. **認可**: Row Level Security等の適切な権限制御
3. **入力検証**: フロント・バックエンド両方で実施
4. **機密情報**: 環境変数で管理

## 🚀 開発フロー

### 標準開発プロセス

1. **`docs/`を読んで理解する**
2. **Issue作成**: 作業開始前に必須
3. **ブランチ作成**: feature/[機能名] or fix/[バグ名]
4. **開発**: 上記ルールに従って実装
5. **テスト**: 自動テスト実行
6. **ドキュメントの更新**（必要に応じて）
7. **PR作成**: レビュー依頼
8. **マージ**: main/developへ

### 📌 標準タスク実行ルール

**すべてのタスク実行時には必ず以下を実施すること：**

1. **ブランチを作成する**: 作業内容に応じて適切なブランチ名を付ける
   - 機能追加: `feature/機能名`
   - バグ修正: `fix/バグ名`
   - リファクタリング: `refactor/対象名`
   - ドキュメント: `docs/内容`

2. **ローカル品質チェック必須**: コミット・プッシュ前に必ず実行

   ```bash
   npm run quality:check  # lint + type-check + format:check + test:ci
   ```

   - 全てパスしてからコミットすること
   - これによりリモートCI失敗を防ぐ
   - **絶対に守ること**: ローカルでパスしない限りコミット・プッシュ禁止

3. **コミットを作成する**: 変更内容を明確に記述

4. **プルリクエストを作成する**: レビューのためのPRを作成

これは標準ルールとして、すべてのタスクで適用される。

### 🔗 Issue関連PR作成ルール

**Issue対応のPRには必ずIssue自動クローズ記述を含めること：**

- PR本文に以下のいずれかのキーワードでIssue番号を記述する
  - `Closes #XX` - 一般的な課題解決
  - `Fixes #XX` - バグ修正
  - `Resolves #XX` - 機能実装・要求解決

**例：**

```
## Summary
新機能を実装しました

Closes #14
```

## 📝 Git運用ルール

### 作業前の確認

- **ステージングする前に必ず差分を確認し、意図しない変更が含まれていないかチェックする**
- コミット前に`git status`と`git diff --staged`で変更内容を確認する

### コミット規約

1. **形式**: 日本語でのConventional Commits
   ```
   feat: 新機能追加
   fix: バグ修正
   chore: ビルド・設定変更
   docs: ドキュメント変更
   style: コードスタイル変更
   refactor: リファクタリング
   test: テスト追加・修正
   ```

2. **例**:
   ```
   feat: ユーザー認証機能を追加
   fix: フォーム送信時のエラーハンドリングを修正
   docs: API仕様書を更新
   ```

### プルリクエスト

- **タイトル**: 日本語で記述
- **本文**: 日本語で記述
- **技術用語**: 英語の固有名詞はそのまま使用

**例:**

```
タイトル: ユーザー認証機能の実装

## 概要
新しいユーザー認証システムを実装しました。

## 変更内容
- JWT認証の実装
- ログイン/ログアウト機能
- パスワードリセット機能

Closes #15
```

## 🧹 継続的改善とリファクタリング

### 実施タイミング

- **定期実施**: 月1回以上
- **機能追加前**: 大きな機能追加の前
- **品質低下時**: ESLintエラー増加、型エラー頻発時
- **PR前**: 大きな変更をPRする前

### チェック項目

#### 1. 型定義の健全性
- [ ] `src/types/index.ts`の型定義が最新か
- [ ] 複数ファイルで同じ型が重複していないか
- [ ] 命名規則が統一されているか（snake_case vs camelCase）
- [ ] 不要な型定義が残っていないか

#### 2. ユーティリティ関数の重複
- [ ] 同じ処理をする関数が複数箇所にないか
- [ ] `src/lib/utils.ts`に共通化できる処理はないか
- [ ] フォーマット関数（日付、金額等）が統一されているか
- [ ] 計算ロジックが関数化されているか

#### 3. インポート・依存関係
- [ ] インポートパスが統一されているか
- [ ] 不要な依存関係がないか
- [ ] 存在しないモジュールを参照していないか
- [ ] 循環依存がないか

#### 4. コンポーネント設計
- [ ] 責務が適切に分離されているか
- [ ] 再利用可能な粒度になっているか
- [ ] props の型定義が適切か
- [ ] 不要な状態管理がないか

#### 5. 品質指標
- [ ] ESLintエラー0件
- [ ] TypeScriptコンパイルエラー0件
- [ ] テスト成功率100%
- [ ] ビルド成功

### コード重複監視

**similarity-ts定期チェック:**

- **頻度**: 月1回以上
- **実行コマンド**: `similarity-ts .` (要Rust環境)
- **対象**: TypeScript/JSファイルの構造的重複
- **閾値**: 90%以上の類似度で要確認
- **目的**: コード重複の早期発見と品質維持

### 実施手順
1. **現状分析**: 上記チェック項目の確認
2. **問題特定**: 重複、不整合、非効率な箇所の洗い出し
3. **優先順位付け**: 影響度とリスクに基づく作業順序決定
4. **段階的修正**: 小さな単位での確実な修正
5. **テスト実行**: 各修正後の品質確認
6. **文書化**: 変更内容と理由の記録

## 📚 開発者向けドキュメント管理

### docsディレクトリ構造

```
docs/
├── project/           # プロジェクト概要・ビジョン
├── architecture/      # 技術アーキテクチャ・設計
├── development/       # 開発フロー・コード規約
├── api/              # API仕様書
└── deployment/       # デプロイ・運用手順
```

### 必須確認事項

- **新機能開発時**: `docs/project/README.md`でビジネス要件確認
- **技術選定時**: `docs/architecture/README.md`で技術スタック確認
- **コード作成時**: `docs/development/README.md`でコード規約確認
- **API作成時**: `docs/api/README.md`で設計方針確認

### ドキュメント更新ルール

1. **機能追加・変更時**: 該当ドキュメントの更新必須
2. **アーキテクチャ変更時**: `docs/architecture/README.md`更新必須
3. **開発ルール変更時**: `docs/development/README.md`更新必須
4. **大きな変更時**: プロジェクトオーナーに事前確認

### Single Source of Truth原則

- **ビジネス仕様**: `docs/project/README.md`
- **技術仕様**: `docs/architecture/README.md`
- **開発規約**: `docs/development/README.md`
- **実装**: コードそのもの（API仕様、DBスキーマ等は自動生成）

## 🤖 Gemini CLI 連携ガイド

### 目的

ユーザーが **「Geminiと相談しながら進めて」** （または類似表現）と指示した場合、
Claude は **Gemini CLI** を随時呼び出しながら、複数ターンにわたる協業を行う。
実装はGeminiに相談しなくても良い

### トリガー

- 正規表現: `/Gemini.*相談しながら/`
- 一度トリガーした後は、ユーザーが明示的に終了を指示するまで **協業モード** を維持する。

### 協業ワークフロー (ループ可)

| #   | 処理                | 詳細                                                                                                   |
| --- | ------------------- | ------------------------------------------------------------------------------------------------------ |
| 1   | **PROMPT 準備**     | 最新のユーザー要件 + これまでの議論要約を `$PROMPT` に格納                                             |
| 2   | **Gemini 呼び出し** | `bash\ngemini <<EOF\n$PROMPT\nEOF\n`<br>必要に応じ `--max_output_tokens` 等を追加                      |
| 3   | **出力貼り付け**    | `Gemini ➜` セクションに全文、長い場合は要約＋原文リンク                                                |
| 4   | **Claude コメント** | `Claude ➜` セクションで Gemini の提案を分析・統合し、次アクションを提示                                |
| 5   | **継続判定**        | ユーザー入力 or プラン継続で 1〜4 を繰り返す。<br>「Geminiコラボ終了」「ひとまずOK」等で通常モード復帰 |

### 形式テンプレート

```md
**Gemini ➜**
<Gemini からの応答>
**Claude ➜**
<統合コメント & 次アクション>
```

## 🧪 テスト方針

### 必須テスト

1. **ユニットテスト**:
   - フレームワーク: Jest
   - カバレッジ目標: 80%以上
   - 対象: ビジネスロジック、ユーティリティ関数

2. **E2Eテスト**:
   - フレームワーク: Playwright
   - 対象: クリティカルパス、主要ユーザーフロー

3. **統合テスト**:
   - 対象: API、データベース連携
   - モック: 適切にモック化

### テスト戦略

- **テストピラミッド**: ユニット > 統合 > E2E
- **テスト駆動**: TDDサイクルの遵守
- **継続的テスト**: CI/CDでの自動実行

## 🎨 UI/UX原則

### アクセシビリティ

1. **40-50歳向けアクセシビリティ最優先**
   - 文字サイズ調整機能は全ページ必須
   - アイコンよりもテキストボタンを優先
   - ボタンサイズは最小36px以上
   - 十分なクリック領域とコントラスト比の確保

2. **レスポンシブデザイン**
   - 文字サイズ、行間、余白は相対的に調整
   - CSS変数を使用した統一的なスケーリング
   - 小さなUI要素（16px未満のアイコン等）は使用禁止

### デザイン原則

3. **モバイルファースト**: スマートフォンでの操作性を優先
4. **即座の反映**: 入力データは即座にUIに反映
5. **エラー表示**: ユーザーフレンドリーなメッセージ
6. **ローディング**: 処理中は必ずローディング表示

### パフォーマンス目標

1. **初回表示**: 3秒以内
2. **画面遷移**: 1秒以内
3. **API応答**: 500ms以内

## ❓ よくある質問

### Q: 新しい画面を追加する場合は？

A: 
1. `docs/requirements-and-screens.md`に画面定義を追加
2. `/apps/web/src/app/`に新しいルートを作成
3. 必要なコンポーネントを`/apps/web/src/components/`に実装

### Q: AI機能を実装する場合は？

A: 
1. 画像分析などのAI機能は、適切なクラウドサービスを活用
2. クライアント側では進捗状況を表示し、UXを向上させる
3. エラーハンドリングを適切に実装し、フォールバック処理を用意

### Q: リファクタリングはどのくらいの頻度で行うべき？

A:
1. **定期実施**: 月1回以上の定期チェック
2. **機能追加前**: 大きな機能追加の前に実施
3. **品質低下時**: ESLintエラーや型エラーが頻発した際
4. 上記の「📊 リファクタリング標準プロセス」に従って実施する

### Q: 同一エラーが3回続いた場合は？

A:
1. **根本原因分析**: エラーの真の原因を特定
2. **対策検討**: 恒久的な解決策を立案
3. **プロセス改善**: 同様のエラーを防ぐ仕組みを構築
4. **ドキュメント化**: 知見を共有し、再発防止

## 🔄 継続的改善

このドキュメントは生きたドキュメントです。新しいルールや改善点があれば、上記の継続的ルール改善プロセスに従って追加してください。

---

**最終更新**: 2024年12月
**バージョン**: 2.0
**次回レビュー予定**: 2025年1月

