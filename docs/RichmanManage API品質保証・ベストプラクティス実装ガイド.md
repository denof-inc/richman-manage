# RichmanManage APIå“è³ªä¿è¨¼ãƒ»ãƒ™ã‚¹ãƒˆãƒ—ãƒ©ã‚¯ãƒ†ã‚£ã‚¹å®Ÿè£…ã‚¬ã‚¤ãƒ‰

**ä½œæˆæ—¥**: 2025-01-04  
**å¯¾è±¡**: Issue #80 - APIã‚¨ãƒ³ãƒ‰ãƒã‚¤ãƒ³ãƒˆã®å®Ÿè£…  
**å“è³ªãƒ¬ãƒ™ãƒ«**: ã‚¨ãƒ³ã‚¿ãƒ¼ãƒ—ãƒ©ã‚¤ã‚ºã‚°ãƒ¬ãƒ¼ãƒ‰ + ä¸–ç•Œã‚¯ãƒ©ã‚¹å“è³ª  
**ä½œæˆè€…**: Manus AI (è¶…ä¸€æµãƒ†ãƒƒã‚¯ãƒªãƒ¼ãƒ‰)  
**å“è³ªåŸºæº–**: Fortune 500ä¼æ¥­ãƒ¬ãƒ™ãƒ«

---

## ğŸ¯ å“è³ªä¿è¨¼ãƒ•ãƒ¬ãƒ¼ãƒ ãƒ¯ãƒ¼ã‚¯æ¦‚è¦

### ğŸ“Š å“è³ªä¿è¨¼ã®æˆ¦ç•¥çš„é‡è¦æ€§

RichmanManage APIã®å“è³ªä¿è¨¼ã¯ã€å˜ãªã‚‹ãƒã‚°æ¤œå‡ºã‚’è¶…ãˆãŸæˆ¦ç•¥çš„ä¾¡å€¤ã‚’æä¾›ã—ã¾ã™ã€‚ã‚¨ãƒ³ã‚¿ãƒ¼ãƒ—ãƒ©ã‚¤ã‚ºã‚°ãƒ¬ãƒ¼ãƒ‰ã®ã‚·ã‚¹ãƒ†ãƒ ã¨ã—ã¦ã€ãƒ¦ãƒ¼ã‚¶ãƒ¼ã®è²´é‡ãªä¸å‹•ç”£æŠ•è³‡ãƒ‡ãƒ¼ã‚¿ã‚’æ‰±ã†è²¬ä»»ã‚’è² ã†ãŸã‚ã€æœ€é«˜æ°´æº–ã®å“è³ªåŸºæº–ã‚’ç¶­æŒã™ã‚‹ã“ã¨ãŒä¸å¯æ¬ ã§ã™ã€‚

æœ¬ã‚¬ã‚¤ãƒ‰ã¯ã€ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹å®Ÿè£…ã§å®Ÿè¨¼ã•ã‚ŒãŸåŒç­‰ã®ã‚¯ã‚ªãƒªãƒ†ã‚£ã‚’ APIå±¤ã§ã‚‚å®Ÿç¾ã™ã‚‹ãŸã‚ã€åŒ…æ‹¬çš„ãªå“è³ªä¿è¨¼ãƒ•ãƒ¬ãƒ¼ãƒ ãƒ¯ãƒ¼ã‚¯ã‚’æä¾›ã—ã¾ã™ã€‚ç¶™ç¶šçš„å“è³ªæ”¹å–„ã€è‡ªå‹•åŒ–ã•ã‚ŒãŸãƒ†ã‚¹ãƒˆæˆ¦ç•¥ã€ãƒªã‚¢ãƒ«ã‚¿ã‚¤ãƒ ç›£è¦–ã€äºˆé˜²çš„å“è³ªç®¡ç†ã‚’çµ„ã¿åˆã‚ã›ã‚‹ã“ã¨ã§ã€ä¸–ç•Œã‚¯ãƒ©ã‚¹å“è³ªã® API ã‚·ã‚¹ãƒ†ãƒ ã‚’æ§‹ç¯‰ã—ã¾ã™ã€‚

### ğŸ† å“è³ªç›®æ¨™è¨­å®š

**æŠ€è¡“å“è³ªç›®æ¨™**:
- APIå¿œç­”æ™‚é–“: < 200ms (95%ile)
- å¯ç”¨æ€§: > 99.9% (å¹´é–“ãƒ€ã‚¦ãƒ³ã‚¿ã‚¤ãƒ  < 8.76æ™‚é–“)
- ã‚¨ãƒ©ãƒ¼ç‡: < 0.1% (1,000ãƒªã‚¯ã‚¨ã‚¹ãƒˆä¸­1ä»¶æœªæº€)
- ãƒ†ã‚¹ãƒˆã‚«ãƒãƒ¬ãƒƒã‚¸: > 90% (ã‚³ãƒ¼ãƒ‰ã€æ©Ÿèƒ½ã€ã‚·ãƒŠãƒªã‚ª)

**ãƒ“ã‚¸ãƒã‚¹å“è³ªç›®æ¨™**:
- ãƒ¦ãƒ¼ã‚¶ãƒ¼æº€è¶³åº¦: > 95%
- ãƒ‡ãƒ¼ã‚¿æ•´åˆæ€§: 100% (é‡‘èãƒ‡ãƒ¼ã‚¿ã®å®Œå…¨æ€§ç¢ºä¿)
- ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£è„†å¼±æ€§: 0ä»¶ (ç¶™ç¶šçš„ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£ç›£æŸ»)
- è¦åˆ¶æº–æ‹ : 100% (GDPRã€SOXã€ãã®ä»–é–¢é€£æ³•è¦)

**é‹ç”¨å“è³ªç›®æ¨™**:
- å¹³å‡å¾©æ—§æ™‚é–“ (MTTR): < 15åˆ†
- å¹³å‡æ•…éšœé–“éš” (MTBF): > 720æ™‚é–“ (30æ—¥)
- å¤‰æ›´å¤±æ•—ç‡: < 5%
- ãƒ‡ãƒ—ãƒ­ã‚¤é »åº¦: é€±1å›ä»¥ä¸Š

---

## ğŸ§ª åŒ…æ‹¬çš„ãƒ†ã‚¹ãƒˆæˆ¦ç•¥

### ğŸ”¬ ãƒ†ã‚¹ãƒˆãƒ”ãƒ©ãƒŸãƒƒãƒ‰è¨­è¨ˆ

RichmanManage APIã®ãƒ†ã‚¹ãƒˆæˆ¦ç•¥ã¯ã€åŠ¹ç‡çš„ã§ä¿¡é ¼æ€§ã®é«˜ã„ãƒ†ã‚¹ãƒˆãƒ”ãƒ©ãƒŸãƒƒãƒ‰ã‚¢ãƒ—ãƒ­ãƒ¼ãƒã‚’æ¡ç”¨ã—ã¾ã™ã€‚å„ãƒ¬ãƒ™ãƒ«ã§ã®é©åˆ‡ãªãƒ†ã‚¹ãƒˆé…åˆ†ã«ã‚ˆã‚Šã€é«˜ã„å“è³ªä¿è¨¼ã¨åŠ¹ç‡çš„ãªé–‹ç™ºã‚µã‚¤ã‚¯ãƒ«ã‚’ä¸¡ç«‹ã—ã¾ã™ã€‚

```mermaid
graph TB
    A[E2Eãƒ†ã‚¹ãƒˆ - 10%] --> B[çµ±åˆãƒ†ã‚¹ãƒˆ - 20%]
    B --> C[ãƒ¦ãƒ‹ãƒƒãƒˆãƒ†ã‚¹ãƒˆ - 70%]
    
    D[æ‰‹å‹•ãƒ†ã‚¹ãƒˆ] --> E[æ¢ç´¢çš„ãƒ†ã‚¹ãƒˆ]
    D --> F[ãƒ¦ãƒ¼ã‚¶ãƒ“ãƒªãƒ†ã‚£ãƒ†ã‚¹ãƒˆ]
    D --> G[ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£ãƒ†ã‚¹ãƒˆ]
    
    H[ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹ãƒ†ã‚¹ãƒˆ] --> I[è² è·ãƒ†ã‚¹ãƒˆ]
    H --> J[ã‚¹ãƒˆãƒ¬ã‚¹ãƒ†ã‚¹ãƒˆ]
    H --> K[ã‚¹ãƒ‘ã‚¤ã‚¯ãƒ†ã‚¹ãƒˆ]
```

#### ãƒ¦ãƒ‹ãƒƒãƒˆãƒ†ã‚¹ãƒˆå®Ÿè£… (70%)

```typescript
// supabase/functions/tests/unit/property-service.test.ts
import { assertEquals, assertThrows } from 'https://deno.land/std@0.208.0/testing/asserts.ts';
import { describe, it, beforeEach, afterEach } from 'https://deno.land/std@0.208.0/testing/bdd.ts';
import { DatabaseService } from '../../shared/utils/database.ts';
import { CreatePropertySchema } from '../../shared/schemas/property.ts';

describe('PropertyService', () => {
  let dbService: DatabaseService;
  let testUserId: string;
  
  beforeEach(async () => {
    dbService = new DatabaseService();
    testUserId = 'test-user-' + crypto.randomUUID();
    
    // ãƒ†ã‚¹ãƒˆç”¨ãƒ¦ãƒ¼ã‚¶ãƒ¼ã®ä½œæˆ
    await dbService.createTestUser(testUserId);
  });
  
  afterEach(async () => {
    // ãƒ†ã‚¹ãƒˆãƒ‡ãƒ¼ã‚¿ã®ã‚¯ãƒªãƒ¼ãƒ³ã‚¢ãƒƒãƒ—
    await dbService.cleanupTestData(testUserId);
  });
  
  describe('createProperty', () => {
    it('should create property with valid data', async () => {
      const propertyData = {
        name: 'Test Property',
        address: '123 Test St, Test City, TC 12345',
        property_type: 'apartment',
        purchase_price: 250000,
        purchase_date: '2024-01-01T00:00:00Z',
        current_value: 275000,
        lot_size: 1000,
        building_size: 1200,
        year_built: 2020,
        bedrooms: 2,
        bathrooms: 2,
        parking_spaces: 1,
        description: 'Beautiful test property',
        status: 'owned'
      };
      
      const result = await dbService.createProperty(testUserId, propertyData);
      
      assertEquals(result.name, propertyData.name);
      assertEquals(result.user_id, testUserId);
      assertEquals(result.purchase_price, propertyData.purchase_price);
      assertEquals(typeof result.id, 'string');
      assertEquals(typeof result.created_at, 'string');
    });
    
    it('should throw error for invalid property type', async () => {
      const invalidPropertyData = {
        name: 'Test Property',
        address: '123 Test St',
        property_type: 'invalid_type',
        purchase_price: 250000,
        purchase_date: '2024-01-01T00:00:00Z'
      };
      
      await assertThrows(
        async () => {
          await dbService.createProperty(testUserId, invalidPropertyData);
        },
        Error,
        'Invalid property type'
      );
    });
    
    it('should throw error for negative purchase price', async () => {
      const invalidPropertyData = {
        name: 'Test Property',
        address: '123 Test St',
        property_type: 'apartment',
        purchase_price: -100000,
        purchase_date: '2024-01-01T00:00:00Z'
      };
      
      await assertThrows(
        async () => {
          await dbService.createProperty(testUserId, invalidPropertyData);
        },
        Error,
        'Purchase price must be positive'
      );
    });
    
    it('should handle duplicate property names gracefully', async () => {
      const propertyData = {
        name: 'Duplicate Property',
        address: '123 Test St',
        property_type: 'apartment',
        purchase_price: 250000,
        purchase_date: '2024-01-01T00:00:00Z'
      };
      
      // æœ€åˆã®ç‰©ä»¶ã‚’ä½œæˆ
      await dbService.createProperty(testUserId, propertyData);
      
      // åŒã˜åå‰ã§2ã¤ç›®ã®ç‰©ä»¶ã‚’ä½œæˆï¼ˆç•°ãªã‚‹ä½æ‰€ï¼‰
      const duplicatePropertyData = {
        ...propertyData,
        address: '456 Different St'
      };
      
      const result = await dbService.createProperty(testUserId, duplicatePropertyData);
      assertEquals(result.name, duplicatePropertyData.name);
      assertEquals(result.address, duplicatePropertyData.address);
    });
  });
  
  describe('getProperty', () => {
    it('should retrieve existing property', async () => {
      const propertyData = {
        name: 'Retrievable Property',
        address: '789 Retrieve St',
        property_type: 'house',
        purchase_price: 350000,
        purchase_date: '2024-01-01T00:00:00Z'
      };
      
      const created = await dbService.createProperty(testUserId, propertyData);
      const retrieved = await dbService.getProperty(testUserId, created.id);
      
      assertEquals(retrieved.id, created.id);
      assertEquals(retrieved.name, propertyData.name);
      assertEquals(retrieved.user_id, testUserId);
    });
    
    it('should return null for non-existent property', async () => {
      const nonExistentId = crypto.randomUUID();
      const result = await dbService.getProperty(testUserId, nonExistentId);
      
      assertEquals(result, null);
    });
    
    it('should not retrieve property from different user', async () => {
      const otherUserId = 'other-user-' + crypto.randomUUID();
      await dbService.createTestUser(otherUserId);
      
      const propertyData = {
        name: 'Other User Property',
        address: '999 Other St',
        property_type: 'condo',
        purchase_price: 200000,
        purchase_date: '2024-01-01T00:00:00Z'
      };
      
      const created = await dbService.createProperty(otherUserId, propertyData);
      const result = await dbService.getProperty(testUserId, created.id);
      
      assertEquals(result, null);
      
      // ã‚¯ãƒªãƒ¼ãƒ³ã‚¢ãƒƒãƒ—
      await dbService.cleanupTestData(otherUserId);
    });
  });
  
  describe('updateProperty', () => {
    it('should update property with valid data', async () => {
      const originalData = {
        name: 'Original Property',
        address: '111 Original St',
        property_type: 'apartment',
        purchase_price: 300000,
        purchase_date: '2024-01-01T00:00:00Z'
      };
      
      const created = await dbService.createProperty(testUserId, originalData);
      
      const updateData = {
        name: 'Updated Property',
        current_value: 325000,
        description: 'Updated description'
      };
      
      const updated = await dbService.updateProperty(testUserId, created.id, updateData);
      
      assertEquals(updated.name, updateData.name);
      assertEquals(updated.current_value, updateData.current_value);
      assertEquals(updated.description, updateData.description);
      assertEquals(updated.address, originalData.address); // å¤‰æ›´ã•ã‚Œã¦ã„ãªã„é …ç›®
      assertEquals(updated.purchase_price, originalData.purchase_price);
    });
    
    it('should throw error when updating non-existent property', async () => {
      const nonExistentId = crypto.randomUUID();
      const updateData = { name: 'Updated Name' };
      
      await assertThrows(
        async () => {
          await dbService.updateProperty(testUserId, nonExistentId, updateData);
        },
        Error,
        'Property not found'
      );
    });
  });
  
  describe('deleteProperty', () => {
    it('should delete existing property', async () => {
      const propertyData = {
        name: 'Deletable Property',
        address: '222 Delete St',
        property_type: 'house',
        purchase_price: 400000,
        purchase_date: '2024-01-01T00:00:00Z'
      };
      
      const created = await dbService.createProperty(testUserId, propertyData);
      
      await dbService.deleteProperty(testUserId, created.id);
      
      const retrieved = await dbService.getProperty(testUserId, created.id);
      assertEquals(retrieved, null);
    });
    
    it('should throw error when deleting property with related loans', async () => {
      const propertyData = {
        name: 'Property with Loan',
        address: '333 Loan St',
        property_type: 'condo',
        purchase_price: 250000,
        purchase_date: '2024-01-01T00:00:00Z'
      };
      
      const property = await dbService.createProperty(testUserId, propertyData);
      
      // é–¢é€£ã™ã‚‹å€Ÿå…¥ã‚’ä½œæˆ
      const loanData = {
        property_id: property.id,
        lender_name: 'Test Bank',
        loan_amount: 200000,
        interest_rate: 4.5,
        loan_term_months: 360,
        loan_type: 'fixed_rate',
        start_date: '2024-01-01T00:00:00Z',
        monthly_payment: 1013.37
      };
      
      await dbService.createLoan(testUserId, loanData);
      
      await assertThrows(
        async () => {
          await dbService.deleteProperty(testUserId, property.id);
        },
        Error,
        'Cannot delete property with related loans'
      );
    });
  });
  
  describe('searchProperties', () => {
    beforeEach(async () => {
      // ãƒ†ã‚¹ãƒˆç”¨ã®è¤‡æ•°ç‰©ä»¶ã‚’ä½œæˆ
      const properties = [
        {
          name: 'Downtown Apartment',
          address: '100 Downtown Ave, City, ST 12345',
          property_type: 'apartment',
          purchase_price: 300000,
          purchase_date: '2024-01-01T00:00:00Z',
          status: 'owned'
        },
        {
          name: 'Suburban House',
          address: '200 Suburban Rd, Town, ST 67890',
          property_type: 'house',
          purchase_price: 450000,
          purchase_date: '2024-02-01T00:00:00Z',
          status: 'owned'
        },
        {
          name: 'Commercial Building',
          address: '300 Business Blvd, Metro, ST 11111',
          property_type: 'commercial',
          purchase_price: 750000,
          purchase_date: '2024-03-01T00:00:00Z',
          status: 'for_sale'
        }
      ];
      
      for (const property of properties) {
        await dbService.createProperty(testUserId, property);
      }
    });
    
    it('should search properties by name', async () => {
      const searchCriteria = {
        query: 'Downtown',
        page: 1,
        limit: 20,
        sort_by: 'name',
        sort_order: 'asc'
      };
      
      const result = await dbService.searchProperties(testUserId, searchCriteria);
      
      assertEquals(result.properties.length, 1);
      assertEquals(result.properties[0].name, 'Downtown Apartment');
      assertEquals(result.total, 1);
    });
    
    it('should filter properties by type', async () => {
      const searchCriteria = {
        property_type: 'house',
        page: 1,
        limit: 20,
        sort_by: 'purchase_date',
        sort_order: 'desc'
      };
      
      const result = await dbService.searchProperties(testUserId, searchCriteria);
      
      assertEquals(result.properties.length, 1);
      assertEquals(result.properties[0].property_type, 'house');
    });
    
    it('should filter properties by price range', async () => {
      const searchCriteria = {
        min_price: 400000,
        max_price: 800000,
        page: 1,
        limit: 20,
        sort_by: 'purchase_price',
        sort_order: 'asc'
      };
      
      const result = await dbService.searchProperties(testUserId, searchCriteria);
      
      assertEquals(result.properties.length, 2);
      assertEquals(result.properties[0].name, 'Suburban House');
      assertEquals(result.properties[1].name, 'Commercial Building');
    });
    
    it('should handle pagination correctly', async () => {
      const searchCriteria = {
        page: 1,
        limit: 2,
        sort_by: 'purchase_date',
        sort_order: 'asc'
      };
      
      const result = await dbService.searchProperties(testUserId, searchCriteria);
      
      assertEquals(result.properties.length, 2);
      assertEquals(result.total, 3);
      assertEquals(result.properties[0].name, 'Downtown Apartment');
      assertEquals(result.properties[1].name, 'Suburban House');
    });
  });
});
```

#### çµ±åˆãƒ†ã‚¹ãƒˆå®Ÿè£… (20%)

```typescript
// supabase/functions/tests/integration/property-api.test.ts
import { assertEquals, assertExists } from 'https://deno.land/std@0.208.0/testing/asserts.ts';
import { describe, it, beforeEach, afterEach } from 'https://deno.land/std@0.208.0/testing/bdd.ts';

describe('Property API Integration Tests', () => {
  let authToken: string;
  let testUserId: string;
  const baseUrl = 'http://localhost:54321/functions/v1';
  
  beforeEach(async () => {
    // ãƒ†ã‚¹ãƒˆãƒ¦ãƒ¼ã‚¶ãƒ¼ã®ä½œæˆã¨èªè¨¼
    const registerResponse = await fetch(`${baseUrl}/auth/register`, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({
        email: `test-${crypto.randomUUID()}@example.com`,
        password: 'TestPassword123!',
        first_name: 'Test',
        last_name: 'User'
      })
    });
    
    const registerData = await registerResponse.json();
    authToken = registerData.data.access_token;
    testUserId = registerData.data.user.id;
  });
  
  afterEach(async () => {
    // ãƒ†ã‚¹ãƒˆãƒ‡ãƒ¼ã‚¿ã®ã‚¯ãƒªãƒ¼ãƒ³ã‚¢ãƒƒãƒ—
    await fetch(`${baseUrl}/users/delete`, {
      method: 'DELETE',
      headers: {
        'Authorization': `Bearer ${authToken}`,
        'Content-Type': 'application/json'
      }
    });
  });
  
  describe('POST /properties/create', () => {
    it('should create property with valid data', async () => {
      const propertyData = {
        name: 'Integration Test Property',
        address: '123 Integration St, Test City, TC 12345',
        property_type: 'apartment',
        purchase_price: 250000,
        purchase_date: '2024-01-01T00:00:00Z',
        current_value: 275000,
        bedrooms: 2,
        bathrooms: 2
      };
      
      const response = await fetch(`${baseUrl}/properties/create`, {
        method: 'POST',
        headers: {
          'Authorization': `Bearer ${authToken}`,
          'Content-Type': 'application/json'
        },
        body: JSON.stringify(propertyData)
      });
      
      assertEquals(response.status, 201);
      
      const data = await response.json();
      assertEquals(data.success, true);
      assertExists(data.data.property);
      assertEquals(data.data.property.name, propertyData.name);
      assertEquals(data.data.property.user_id, testUserId);
    });
    
    it('should return 400 for invalid data', async () => {
      const invalidData = {
        name: '', // ç©ºã®åå‰
        address: '123 Test St',
        property_type: 'invalid_type',
        purchase_price: -100000 // è² ã®ä¾¡æ ¼
      };
      
      const response = await fetch(`${baseUrl}/properties/create`, {
        method: 'POST',
        headers: {
          'Authorization': `Bearer ${authToken}`,
          'Content-Type': 'application/json'
        },
        body: JSON.stringify(invalidData)
      });
      
      assertEquals(response.status, 400);
      
      const data = await response.json();
      assertEquals(data.success, false);
      assertEquals(data.error.code, 'VALIDATION_ERROR');
      assertExists(data.error.details.errors);
    });
    
    it('should return 401 for unauthenticated request', async () => {
      const propertyData = {
        name: 'Unauthorized Property',
        address: '123 Unauthorized St',
        property_type: 'apartment',
        purchase_price: 250000,
        purchase_date: '2024-01-01T00:00:00Z'
      };
      
      const response = await fetch(`${baseUrl}/properties/create`, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(propertyData)
      });
      
      assertEquals(response.status, 401);
      
      const data = await response.json();
      assertEquals(data.success, false);
      assertEquals(data.error.code, 'UNAUTHORIZED');
    });
  });
  
  describe('GET /properties/read', () => {
    let createdPropertyId: string;
    
    beforeEach(async () => {
      // ãƒ†ã‚¹ãƒˆç”¨ç‰©ä»¶ã®ä½œæˆ
      const propertyData = {
        name: 'Readable Property',
        address: '456 Readable St',
        property_type: 'house',
        purchase_price: 350000,
        purchase_date: '2024-01-01T00:00:00Z'
      };
      
      const createResponse = await fetch(`${baseUrl}/properties/create`, {
        method: 'POST',
        headers: {
          'Authorization': `Bearer ${authToken}`,
          'Content-Type': 'application/json'
        },
        body: JSON.stringify(propertyData)
      });
      
      const createData = await createResponse.json();
      createdPropertyId = createData.data.property.id;
    });
    
    it('should retrieve all properties for user', async () => {
      const response = await fetch(`${baseUrl}/properties/read`, {
        method: 'GET',
        headers: {
          'Authorization': `Bearer ${authToken}`
        }
      });
      
      assertEquals(response.status, 200);
      
      const data = await response.json();
      assertEquals(data.success, true);
      assertExists(data.data.properties);
      assertEquals(Array.isArray(data.data.properties), true);
      assertEquals(data.data.properties.length >= 1, true);
    });
    
    it('should retrieve specific property by ID', async () => {
      const response = await fetch(`${baseUrl}/properties/read/${createdPropertyId}`, {
        method: 'GET',
        headers: {
          'Authorization': `Bearer ${authToken}`
        }
      });
      
      assertEquals(response.status, 200);
      
      const data = await response.json();
      assertEquals(data.success, true);
      assertEquals(data.data.property.id, createdPropertyId);
      assertEquals(data.data.property.name, 'Readable Property');
    });
    
    it('should return 404 for non-existent property', async () => {
      const nonExistentId = crypto.randomUUID();
      
      const response = await fetch(`${baseUrl}/properties/read/${nonExistentId}`, {
        method: 'GET',
        headers: {
          'Authorization': `Bearer ${authToken}`
        }
      });
      
      assertEquals(response.status, 404);
      
      const data = await response.json();
      assertEquals(data.success, false);
      assertEquals(data.error.code, 'NOT_FOUND');
    });
  });
  
  describe('PUT /properties/update', () => {
    let createdPropertyId: string;
    
    beforeEach(async () => {
      const propertyData = {
        name: 'Updatable Property',
        address: '789 Updatable St',
        property_type: 'condo',
        purchase_price: 275000,
        purchase_date: '2024-01-01T00:00:00Z'
      };
      
      const createResponse = await fetch(`${baseUrl}/properties/create`, {
        method: 'POST',
        headers: {
          'Authorization': `Bearer ${authToken}`,
          'Content-Type': 'application/json'
        },
        body: JSON.stringify(propertyData)
      });
      
      const createData = await createResponse.json();
      createdPropertyId = createData.data.property.id;
    });
    
    it('should update property with valid data', async () => {
      const updateData = {
        name: 'Updated Property Name',
        current_value: 300000,
        description: 'Updated description'
      };
      
      const response = await fetch(`${baseUrl}/properties/update/${createdPropertyId}`, {
        method: 'PUT',
        headers: {
          'Authorization': `Bearer ${authToken}`,
          'Content-Type': 'application/json'
        },
        body: JSON.stringify(updateData)
      });
      
      assertEquals(response.status, 200);
      
      const data = await response.json();
      assertEquals(data.success, true);
      assertEquals(data.data.property.name, updateData.name);
      assertEquals(data.data.property.current_value, updateData.current_value);
      assertEquals(data.data.property.description, updateData.description);
    });
    
    it('should return 404 for non-existent property', async () => {
      const nonExistentId = crypto.randomUUID();
      const updateData = { name: 'Updated Name' };
      
      const response = await fetch(`${baseUrl}/properties/update/${nonExistentId}`, {
        method: 'PUT',
        headers: {
          'Authorization': `Bearer ${authToken}`,
          'Content-Type': 'application/json'
        },
        body: JSON.stringify(updateData)
      });
      
      assertEquals(response.status, 404);
      
      const data = await response.json();
      assertEquals(data.success, false);
      assertEquals(data.error.code, 'NOT_FOUND');
    });
  });
  
  describe('DELETE /properties/delete', () => {
    let createdPropertyId: string;
    
    beforeEach(async () => {
      const propertyData = {
        name: 'Deletable Property',
        address: '999 Deletable St',
        property_type: 'house',
        purchase_price: 400000,
        purchase_date: '2024-01-01T00:00:00Z'
      };
      
      const createResponse = await fetch(`${baseUrl}/properties/create`, {
        method: 'POST',
        headers: {
          'Authorization': `Bearer ${authToken}`,
          'Content-Type': 'application/json'
        },
        body: JSON.stringify(propertyData)
      });
      
      const createData = await createResponse.json();
      createdPropertyId = createData.data.property.id;
    });
    
    it('should delete existing property', async () => {
      const response = await fetch(`${baseUrl}/properties/delete/${createdPropertyId}`, {
        method: 'DELETE',
        headers: {
          'Authorization': `Bearer ${authToken}`
        }
      });
      
      assertEquals(response.status, 200);
      
      const data = await response.json();
      assertEquals(data.success, true);
      assertEquals(data.data.message, 'Property deleted successfully');
      
      // å‰Šé™¤ç¢ºèª
      const getResponse = await fetch(`${baseUrl}/properties/read/${createdPropertyId}`, {
        method: 'GET',
        headers: {
          'Authorization': `Bearer ${authToken}`
        }
      });
      
      assertEquals(getResponse.status, 404);
    });
    
    it('should return 404 for non-existent property', async () => {
      const nonExistentId = crypto.randomUUID();
      
      const response = await fetch(`${baseUrl}/properties/delete/${nonExistentId}`, {
        method: 'DELETE',
        headers: {
          'Authorization': `Bearer ${authToken}`
        }
      });
      
      assertEquals(response.status, 404);
      
      const data = await response.json();
      assertEquals(data.success, false);
      assertEquals(data.error.code, 'NOT_FOUND');
    });
  });
  
  describe('GET /properties/search', () => {
    beforeEach(async () => {
      // æ¤œç´¢ç”¨ã®ãƒ†ã‚¹ãƒˆãƒ‡ãƒ¼ã‚¿ã‚’ä½œæˆ
      const properties = [
        {
          name: 'Downtown Apartment',
          address: '100 Downtown Ave',
          property_type: 'apartment',
          purchase_price: 300000,
          purchase_date: '2024-01-01T00:00:00Z'
        },
        {
          name: 'Suburban House',
          address: '200 Suburban Rd',
          property_type: 'house',
          purchase_price: 450000,
          purchase_date: '2024-02-01T00:00:00Z'
        },
        {
          name: 'Commercial Building',
          address: '300 Business Blvd',
          property_type: 'commercial',
          purchase_price: 750000,
          purchase_date: '2024-03-01T00:00:00Z'
        }
      ];
      
      for (const property of properties) {
        await fetch(`${baseUrl}/properties/create`, {
          method: 'POST',
          headers: {
            'Authorization': `Bearer ${authToken}`,
            'Content-Type': 'application/json'
          },
          body: JSON.stringify(property)
        });
      }
    });
    
    it('should search properties by query', async () => {
      const searchParams = new URLSearchParams({
        query: 'Downtown',
        page: '1',
        limit: '20'
      });
      
      const response = await fetch(`${baseUrl}/properties/search?${searchParams}`, {
        method: 'GET',
        headers: {
          'Authorization': `Bearer ${authToken}`
        }
      });
      
      assertEquals(response.status, 200);
      
      const data = await response.json();
      assertEquals(data.success, true);
      assertEquals(data.data.properties.length, 1);
      assertEquals(data.data.properties[0].name, 'Downtown Apartment');
      assertEquals(data.data.pagination.total, 1);
    });
    
    it('should filter properties by type', async () => {
      const searchParams = new URLSearchParams({
        property_type: 'house',
        page: '1',
        limit: '20'
      });
      
      const response = await fetch(`${baseUrl}/properties/search?${searchParams}`, {
        method: 'GET',
        headers: {
          'Authorization': `Bearer ${authToken}`
        }
      });
      
      assertEquals(response.status, 200);
      
      const data = await response.json();
      assertEquals(data.success, true);
      assertEquals(data.data.properties.length, 1);
      assertEquals(data.data.properties[0].property_type, 'house');
    });
    
    it('should filter properties by price range', async () => {
      const searchParams = new URLSearchParams({
        min_price: '400000',
        max_price: '800000',
        page: '1',
        limit: '20'
      });
      
      const response = await fetch(`${baseUrl}/properties/search?${searchParams}`, {
        method: 'GET',
        headers: {
          'Authorization': `Bearer ${authToken}`
        }
      });
      
      assertEquals(response.status, 200);
      
      const data = await response.json();
      assertEquals(data.success, true);
      assertEquals(data.data.properties.length, 2);
      assertEquals(data.data.pagination.total, 2);
    });
    
    it('should handle pagination correctly', async () => {
      const searchParams = new URLSearchParams({
        page: '1',
        limit: '2',
        sort_by: 'purchase_date',
        sort_order: 'asc'
      });
      
      const response = await fetch(`${baseUrl}/properties/search?${searchParams}`, {
        method: 'GET',
        headers: {
          'Authorization': `Bearer ${authToken}`
        }
      });
      
      assertEquals(response.status, 200);
      
      const data = await response.json();
      assertEquals(data.success, true);
      assertEquals(data.data.properties.length, 2);
      assertEquals(data.data.pagination.total >= 3, true);
      assertEquals(data.data.pagination.page, 1);
      assertEquals(data.data.pagination.limit, 2);
    });
  });
});
```

#### E2Eãƒ†ã‚¹ãƒˆå®Ÿè£… (10%)

```typescript
// supabase/functions/tests/e2e/property-workflow.test.ts
import { assertEquals, assertExists } from 'https://deno.land/std@0.208.0/testing/asserts.ts';
import { describe, it, beforeEach, afterEach } from 'https://deno.land/std@0.208.0/testing/bdd.ts';

describe('Property Management E2E Workflow', () => {
  let authToken: string;
  let testUserId: string;
  const baseUrl = 'http://localhost:54321/functions/v1';
  
  beforeEach(async () => {
    // ãƒ¦ãƒ¼ã‚¶ãƒ¼ç™»éŒ²
    const registerResponse = await fetch(`${baseUrl}/auth/register`, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({
        email: `e2e-test-${crypto.randomUUID()}@example.com`,
        password: 'E2ETestPassword123!',
        first_name: 'E2E',
        last_name: 'Tester'
      })
    });
    
    const registerData = await registerResponse.json();
    authToken = registerData.data.access_token;
    testUserId = registerData.data.user.id;
  });
  
  afterEach(async () => {
    // å…¨ãƒ†ã‚¹ãƒˆãƒ‡ãƒ¼ã‚¿ã®ã‚¯ãƒªãƒ¼ãƒ³ã‚¢ãƒƒãƒ—
    await fetch(`${baseUrl}/users/delete`, {
      method: 'DELETE',
      headers: {
        'Authorization': `Bearer ${authToken}`,
        'Content-Type': 'application/json'
      }
    });
  });
  
  it('should complete full property investment workflow', async () => {
    // Step 1: ç‰©ä»¶ä½œæˆ
    const propertyData = {
      name: 'E2E Investment Property',
      address: '123 Investment Ave, Real Estate City, RE 12345',
      property_type: 'apartment',
      purchase_price: 500000,
      purchase_date: '2024-01-01T00:00:00Z',
      current_value: 525000,
      lot_size: 2000,
      building_size: 2500,
      year_built: 2020,
      bedrooms: 3,
      bathrooms: 2,
      parking_spaces: 2,
      description: 'Excellent investment property in prime location'
    };
    
    const createPropertyResponse = await fetch(`${baseUrl}/properties/create`, {
      method: 'POST',
      headers: {
        'Authorization': `Bearer ${authToken}`,
        'Content-Type': 'application/json'
      },
      body: JSON.stringify(propertyData)
    });
    
    assertEquals(createPropertyResponse.status, 201);
    const propertyResult = await createPropertyResponse.json();
    const propertyId = propertyResult.data.property.id;
    
    // Step 2: å€Ÿå…¥ä½œæˆ
    const loanData = {
      property_id: propertyId,
      lender_name: 'E2E Investment Bank',
      loan_amount: 400000,
      interest_rate: 4.25,
      loan_term_months: 360,
      loan_type: 'fixed_rate',
      start_date: '2024-01-01T00:00:00Z',
      monthly_payment: 1967.15,
      down_payment: 100000,
      closing_costs: 5000
    };
    
    const createLoanResponse = await fetch(`${baseUrl}/loans/create`, {
      method: 'POST',
      headers: {
        'Authorization': `Bearer ${authToken}`,
        'Content-Type': 'application/json'
      },
      body: JSON.stringify(loanData)
    });
    
    assertEquals(createLoanResponse.status, 201);
    const loanResult = await createLoanResponse.json();
    const loanId = loanResult.data.loan.id;
    
    // Step 3: ãƒ¬ãƒ³ãƒˆãƒ­ãƒ¼ãƒ«ä½œæˆï¼ˆè¤‡æ•°ãƒ¦ãƒ‹ãƒƒãƒˆï¼‰
    const rentRollUnits = [
      {
        property_id: propertyId,
        unit_number: '1A',
        unit_type: '2br',
        square_footage: 1000,
        tenant_name: 'John Doe',
        lease_start_date: '2024-01-01T00:00:00Z',
        lease_end_date: '2024-12-31T23:59:59Z',
        monthly_rent: 2200,
        security_deposit: 2200,
        lease_status: 'active',
        tenant_email: 'john.doe@example.com',
        tenant_phone: '555-0101'
      },
      {
        property_id: propertyId,
        unit_number: '1B',
        unit_type: '2br',
        square_footage: 1000,
        tenant_name: 'Jane Smith',
        lease_start_date: '2024-02-01T00:00:00Z',
        lease_end_date: '2025-01-31T23:59:59Z',
        monthly_rent: 2300,
        security_deposit: 2300,
        lease_status: 'active',
        tenant_email: 'jane.smith@example.com',
        tenant_phone: '555-0102'
      },
      {
        property_id: propertyId,
        unit_number: '2A',
        unit_type: '1br',
        square_footage: 750,
        monthly_rent: 1800,
        lease_status: 'vacant'
      }
    ];
    
    const rentRollIds = [];
    for (const unit of rentRollUnits) {
      const createRentRollResponse = await fetch(`${baseUrl}/rent-rolls/create`, {
        method: 'POST',
        headers: {
          'Authorization': `Bearer ${authToken}`,
          'Content-Type': 'application/json'
        },
        body: JSON.stringify(unit)
      });
      
      assertEquals(createRentRollResponse.status, 201);
      const rentRollResult = await createRentRollResponse.json();
      rentRollIds.push(rentRollResult.data.rent_roll.id);
    }
    
    // Step 4: è³ƒæ–™æ”¯æ‰•ã„è¨˜éŒ²
    const rentPaymentData = {
      rent_roll_id: rentRollIds[0],
      payment_date: '2024-01-01T00:00:00Z',
      amount_paid: 2200,
      payment_method: 'bank_transfer',
      notes: 'First month rent payment'
    };
    
    const createPaymentResponse = await fetch(`${baseUrl}/rent-rolls/payment`, {
      method: 'POST',
      headers: {
        'Authorization': `Bearer ${authToken}`,
        'Content-Type': 'application/json'
      },
      body: JSON.stringify(rentPaymentData)
    });
    
    assertEquals(createPaymentResponse.status, 201);
    
    // Step 5: ç‰©ä»¶åˆ†æãƒ¬ãƒãƒ¼ãƒˆå–å¾—
    const analyticsResponse = await fetch(`${baseUrl}/properties/${propertyId}/analytics`, {
      method: 'GET',
      headers: {
        'Authorization': `Bearer ${authToken}`
      }
    });
    
    assertEquals(analyticsResponse.status, 200);
    const analyticsResult = await analyticsResponse.json();
    
    // åˆ†æçµæœã®æ¤œè¨¼
    assertExists(analyticsResult.data.property_analytics);
    assertEquals(analyticsResult.data.property_analytics.total_units, 3);
    assertEquals(analyticsResult.data.property_analytics.occupied_units, 2);
    assertEquals(analyticsResult.data.property_analytics.vacant_units, 1);
    assertEquals(analyticsResult.data.property_analytics.total_monthly_income, 4500);
    
    // Step 6: æŠ•è³‡åç›Šè¨ˆç®—
    const roiResponse = await fetch(`${baseUrl}/properties/${propertyId}/roi`, {
      method: 'GET',
      headers: {
        'Authorization': `Bearer ${authToken}`
      }
    });
    
    assertEquals(roiResponse.status, 200);
    const roiResult = await roiResponse.json();
    
    // ROIè¨ˆç®—çµæœã®æ¤œè¨¼
    assertExists(roiResult.data.roi_analysis);
    assertEquals(typeof roiResult.data.roi_analysis.annual_cash_flow, 'number');
    assertEquals(typeof roiResult.data.roi_analysis.cash_on_cash_return, 'number');
    assertEquals(typeof roiResult.data.roi_analysis.cap_rate, 'number');
    
    // Step 7: ç‰©ä»¶æ›´æ–°ï¼ˆå¸‚å ´ä¾¡å€¤ã®æ›´æ–°ï¼‰
    const updatePropertyData = {
      current_value: 550000,
      description: 'Updated property value based on recent market analysis'
    };
    
    const updatePropertyResponse = await fetch(`${baseUrl}/properties/update/${propertyId}`, {
      method: 'PUT',
      headers: {
        'Authorization': `Bearer ${authToken}`,
        'Content-Type': 'application/json'
      },
      body: JSON.stringify(updatePropertyData)
    });
    
    assertEquals(updatePropertyResponse.status, 200);
    const updatedProperty = await updatePropertyResponse.json();
    assertEquals(updatedProperty.data.property.current_value, 550000);
    
    // Step 8: åŒ…æ‹¬çš„ãƒ¬ãƒãƒ¼ãƒˆç”Ÿæˆ
    const reportResponse = await fetch(`${baseUrl}/reports/property/${propertyId}`, {
      method: 'GET',
      headers: {
        'Authorization': `Bearer ${authToken}`
      }
    });
    
    assertEquals(reportResponse.status, 200);
    const reportResult = await reportResponse.json();
    
    // ãƒ¬ãƒãƒ¼ãƒˆå†…å®¹ã®æ¤œè¨¼
    assertExists(reportResult.data.comprehensive_report);
    assertExists(reportResult.data.comprehensive_report.property_summary);
    assertExists(reportResult.data.comprehensive_report.financial_summary);
    assertExists(reportResult.data.comprehensive_report.rental_summary);
    assertExists(reportResult.data.comprehensive_report.performance_metrics);
    
    // Step 9: ãƒ‡ãƒ¼ã‚¿æ•´åˆæ€§ã®æœ€çµ‚ç¢ºèª
    const finalPropertyResponse = await fetch(`${baseUrl}/properties/read/${propertyId}`, {
      method: 'GET',
      headers: {
        'Authorization': `Bearer ${authToken}`
      }
    });
    
    assertEquals(finalPropertyResponse.status, 200);
    const finalProperty = await finalPropertyResponse.json();
    
    // å…¨ãƒ‡ãƒ¼ã‚¿ã®æ•´åˆæ€§ç¢ºèª
    assertEquals(finalProperty.data.property.id, propertyId);
    assertEquals(finalProperty.data.property.current_value, 550000);
    assertEquals(finalProperty.data.property.user_id, testUserId);
  });
  
  it('should handle concurrent property operations correctly', async () => {
    // ä¸¦è¡Œå‡¦ç†ãƒ†ã‚¹ãƒˆï¼šè¤‡æ•°ã®ç‰©ä»¶ã‚’åŒæ™‚ã«ä½œæˆãƒ»æ›´æ–°ãƒ»å‰Šé™¤
    const concurrentOperations = [];
    
    // 5ã¤ã®ç‰©ä»¶ã‚’ä¸¦è¡Œä½œæˆ
    for (let i = 0; i < 5; i++) {
      const propertyData = {
        name: `Concurrent Property ${i + 1}`,
        address: `${100 + i} Concurrent St`,
        property_type: 'apartment',
        purchase_price: 250000 + (i * 50000),
        purchase_date: '2024-01-01T00:00:00Z'
      };
      
      concurrentOperations.push(
        fetch(`${baseUrl}/properties/create`, {
          method: 'POST',
          headers: {
            'Authorization': `Bearer ${authToken}`,
            'Content-Type': 'application/json'
          },
          body: JSON.stringify(propertyData)
        })
      );
    }
    
    const createResults = await Promise.all(concurrentOperations);
    
    // å…¨ã¦ã®ä½œæˆãŒæˆåŠŸã—ãŸã“ã¨ã‚’ç¢ºèª
    for (const result of createResults) {
      assertEquals(result.status, 201);
    }
    
    // ä½œæˆã•ã‚ŒãŸç‰©ä»¶ã®å–å¾—
    const getPropertiesResponse = await fetch(`${baseUrl}/properties/read`, {
      method: 'GET',
      headers: {
        'Authorization': `Bearer ${authToken}`
      }
    });
    
    assertEquals(getPropertiesResponse.status, 200);
    const propertiesData = await getPropertiesResponse.json();
    assertEquals(propertiesData.data.properties.length, 5);
    
    // ãƒ‡ãƒ¼ã‚¿æ•´åˆæ€§ã®ç¢ºèª
    const propertyNames = propertiesData.data.properties.map(p => p.name).sort();
    const expectedNames = Array.from({length: 5}, (_, i) => `Concurrent Property ${i + 1}`).sort();
    assertEquals(JSON.stringify(propertyNames), JSON.stringify(expectedNames));
  });
  
  it('should maintain data consistency during error scenarios', async () => {
    // ã‚¨ãƒ©ãƒ¼ã‚·ãƒŠãƒªã‚ªã§ã®ãƒ‡ãƒ¼ã‚¿æ•´åˆæ€§ãƒ†ã‚¹ãƒˆ
    
    // Step 1: æ­£å¸¸ãªç‰©ä»¶ä½œæˆ
    const propertyData = {
      name: 'Error Test Property',
      address: '999 Error Test St',
      property_type: 'house',
      purchase_price: 300000,
      purchase_date: '2024-01-01T00:00:00Z'
    };
    
    const createPropertyResponse = await fetch(`${baseUrl}/properties/create`, {
      method: 'POST',
      headers: {
        'Authorization': `Bearer ${authToken}`,
        'Content-Type': 'application/json'
      },
      body: JSON.stringify(propertyData)
    });
    
    assertEquals(createPropertyResponse.status, 201);
    const propertyResult = await createPropertyResponse.json();
    const propertyId = propertyResult.data.property.id;
    
    // Step 2: ç„¡åŠ¹ãªãƒ‡ãƒ¼ã‚¿ã§å€Ÿå…¥ä½œæˆã‚’è©¦è¡Œï¼ˆå¤±æ•—ã™ã‚‹ã¯ãšï¼‰
    const invalidLoanData = {
      property_id: propertyId,
      lender_name: '', // ç©ºã®è²¸ã—æ‰‹å
      loan_amount: -100000, // è² ã®é‡‘é¡
      interest_rate: 150, // ç•°å¸¸ã«é«˜ã„é‡‘åˆ©
      loan_term_months: 0, // ç„¡åŠ¹ãªæœŸé–“
      loan_type: 'invalid_type',
      start_date: 'invalid_date',
      monthly_payment: -1000
    };
    
    const createInvalidLoanResponse = await fetch(`${baseUrl}/loans/create`, {
      method: 'POST',
      headers: {
        'Authorization': `Bearer ${authToken}`,
        'Content-Type': 'application/json'
      },
      body: JSON.stringify(invalidLoanData)
    });
    
    assertEquals(createInvalidLoanResponse.status, 400);
    
    // Step 3: ç‰©ä»¶ãŒæ­£å¸¸ãªçŠ¶æ…‹ã‚’ç¶­æŒã—ã¦ã„ã‚‹ã“ã¨ã‚’ç¢ºèª
    const checkPropertyResponse = await fetch(`${baseUrl}/properties/read/${propertyId}`, {
      method: 'GET',
      headers: {
        'Authorization': `Bearer ${authToken}`
      }
    });
    
    assertEquals(checkPropertyResponse.status, 200);
    const checkPropertyResult = await checkPropertyResponse.json();
    assertEquals(checkPropertyResult.data.property.name, propertyData.name);
    
    // Step 4: å€Ÿå…¥ãŒä½œæˆã•ã‚Œã¦ã„ãªã„ã“ã¨ã‚’ç¢ºèª
    const getLoansResponse = await fetch(`${baseUrl}/loans/read?property_id=${propertyId}`, {
      method: 'GET',
      headers: {
        'Authorization': `Bearer ${authToken}`
      }
    });
    
    assertEquals(getLoansResponse.status, 200);
    const loansResult = await getLoansResponse.json();
    assertEquals(loansResult.data.loans.length, 0);
    
    // Step 5: æ­£å¸¸ãªå€Ÿå…¥ä½œæˆã§å›å¾©
    const validLoanData = {
      property_id: propertyId,
      lender_name: 'Recovery Bank',
      loan_amount: 240000,
      interest_rate: 4.5,
      loan_term_months: 360,
      loan_type: 'fixed_rate',
      start_date: '2024-01-01T00:00:00Z',
      monthly_payment: 1216.04
    };
    
    const createValidLoanResponse = await fetch(`${baseUrl}/loans/create`, {
      method: 'POST',
      headers: {
        'Authorization': `Bearer ${authToken}`,
        'Content-Type': 'application/json'
      },
      body: JSON.stringify(validLoanData)
    });
    
    assertEquals(createValidLoanResponse.status, 201);
    
    // æœ€çµ‚çš„ãªãƒ‡ãƒ¼ã‚¿æ•´åˆæ€§ç¢ºèª
    const finalLoansResponse = await fetch(`${baseUrl}/loans/read?property_id=${propertyId}`, {
      method: 'GET',
      headers: {
        'Authorization': `Bearer ${authToken}`
      }
    });
    
    assertEquals(finalLoansResponse.status, 200);
    const finalLoansResult = await finalLoansResponse.json();
    assertEquals(finalLoansResult.data.loans.length, 1);
    assertEquals(finalLoansResult.data.loans[0].lender_name, 'Recovery Bank');
  });
});
```

---

## ğŸ”’ ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£ãƒ†ã‚¹ãƒˆå®Ÿè£…

### ğŸ›¡ï¸ ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£ãƒ†ã‚¹ãƒˆæˆ¦ç•¥

```typescript
// supabase/functions/tests/security/auth-security.test.ts
import { assertEquals, assertThrows } from 'https://deno.land/std@0.208.0/testing/asserts.ts';
import { describe, it, beforeEach, afterEach } from 'https://deno.land/std@0.208.0/testing/bdd.ts';

describe('Authentication Security Tests', () => {
  const baseUrl = 'http://localhost:54321/functions/v1';
  
  describe('JWT Token Security', () => {
    it('should reject expired tokens', async () => {
      // æœŸé™åˆ‡ã‚Œãƒˆãƒ¼ã‚¯ãƒ³ã®ç”Ÿæˆï¼ˆãƒ†ã‚¹ãƒˆç”¨ï¼‰
      const expiredToken = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiJ0ZXN0LXVzZXIiLCJleHAiOjE2MDk0NTkyMDB9.invalid';
      
      const response = await fetch(`${baseUrl}/properties/read`, {
        method: 'GET',
        headers: {
          'Authorization': `Bearer ${expiredToken}`
        }
      });
      
      assertEquals(response.status, 401);
      
      const data = await response.json();
      assertEquals(data.error.code, 'UNAUTHORIZED');
    });
    
    it('should reject malformed tokens', async () => {
      const malformedToken = 'invalid.token.format';
      
      const response = await fetch(`${baseUrl}/properties/read`, {
        method: 'GET',
        headers: {
          'Authorization': `Bearer ${malformedToken}`
        }
      });
      
      assertEquals(response.status, 401);
    });
    
    it('should reject tokens with invalid signature', async () => {
      const invalidSignatureToken = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiJ0ZXN0LXVzZXIiLCJleHAiOjk5OTk5OTk5OTl9.invalid_signature';
      
      const response = await fetch(`${baseUrl}/properties/read`, {
        method: 'GET',
        headers: {
          'Authorization': `Bearer ${invalidSignatureToken}`
        }
      });
      
      assertEquals(response.status, 401);
    });
  });
  
  describe('Input Validation Security', () => {
    let authToken: string;
    
    beforeEach(async () => {
      // ãƒ†ã‚¹ãƒˆãƒ¦ãƒ¼ã‚¶ãƒ¼ã®ä½œæˆ
      const registerResponse = await fetch(`${baseUrl}/auth/register`, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          email: `security-test-${crypto.randomUUID()}@example.com`,
          password: 'SecurePassword123!',
          first_name: 'Security',
          last_name: 'Tester'
        })
      });
      
      const registerData = await registerResponse.json();
      authToken = registerData.data.access_token;
    });
    
    it('should prevent SQL injection attacks', async () => {
      const sqlInjectionPayloads = [
        "'; DROP TABLE properties; --",
        "' OR '1'='1",
        "'; INSERT INTO properties (name) VALUES ('hacked'); --",
        "' UNION SELECT * FROM users --"
      ];
      
      for (const payload of sqlInjectionPayloads) {
        const propertyData = {
          name: payload,
          address: '123 Test St',
          property_type: 'apartment',
          purchase_price: 250000,
          purchase_date: '2024-01-01T00:00:00Z'
        };
        
        const response = await fetch(`${baseUrl}/properties/create`, {
          method: 'POST',
          headers: {
            'Authorization': `Bearer ${authToken}`,
            'Content-Type': 'application/json'
          },
          body: JSON.stringify(propertyData)
        });
        
        // SQLã‚¤ãƒ³ã‚¸ã‚§ã‚¯ã‚·ãƒ§ãƒ³ã¯é˜²ãŒã‚Œã€é€šå¸¸ã®æ–‡å­—åˆ—ã¨ã—ã¦å‡¦ç†ã•ã‚Œã‚‹ã¹ã
        assertEquals(response.status, 201);
        
        const data = await response.json();
        assertEquals(data.data.property.name, payload); // ã‚¨ã‚¹ã‚±ãƒ¼ãƒ—ã•ã‚ŒãŸçŠ¶æ…‹ã§ä¿å­˜
      }
    });
    
    it('should prevent XSS attacks', async () => {
      const xssPayloads = [
        '<script>alert("XSS")</script>',
        '<img src="x" onerror="alert(1)">',
        'javascript:alert("XSS")',
        '<svg onload="alert(1)">'
      ];
      
      for (const payload of xssPayloads) {
        const propertyData = {
          name: payload,
          address: '123 Test St',
          property_type: 'apartment',
          purchase_price: 250000,
          purchase_date: '2024-01-01T00:00:00Z',
          description: payload
        };
        
        const createResponse = await fetch(`${baseUrl}/properties/create`, {
          method: 'POST',
          headers: {
            'Authorization': `Bearer ${authToken}`,
            'Content-Type': 'application/json'
          },
          body: JSON.stringify(propertyData)
        });
        
        assertEquals(createResponse.status, 201);
        
        const createData = await createResponse.json();
        const propertyId = createData.data.property.id;
        
        // å–å¾—æ™‚ã«XSSãƒšã‚¤ãƒ­ãƒ¼ãƒ‰ãŒé©åˆ‡ã«ã‚¨ã‚¹ã‚±ãƒ¼ãƒ—ã•ã‚Œã¦ã„ã‚‹ã“ã¨ã‚’ç¢ºèª
        const getResponse = await fetch(`${baseUrl}/properties/read/${propertyId}`, {
          method: 'GET',
          headers: {
            'Authorization': `Bearer ${authToken}`
          }
        });
        
        const getData = await getResponse.json();
        
        // HTMLã‚¿ã‚°ãŒé©åˆ‡ã«ã‚¨ã‚¹ã‚±ãƒ¼ãƒ—ã•ã‚Œã¦ã„ã‚‹ã“ã¨ã‚’ç¢ºèª
        assertEquals(getData.data.property.name.includes('<script>'), false);
        assertEquals(getData.data.property.description.includes('<script>'), false);
      }
    });
    
    it('should validate input size limits', async () => {
      // ç•°å¸¸ã«å¤§ããªãƒ‡ãƒ¼ã‚¿ã§ã®ãƒ†ã‚¹ãƒˆ
      const largeString = 'A'.repeat(10000);
      
      const propertyData = {
        name: largeString,
        address: largeString,
        property_type: 'apartment',
        purchase_price: 250000,
        purchase_date: '2024-01-01T00:00:00Z',
        description: largeString
      };
      
      const response = await fetch(`${baseUrl}/properties/create`, {
        method: 'POST',
        headers: {
          'Authorization': `Bearer ${authToken}`,
          'Content-Type': 'application/json'
        },
        body: JSON.stringify(propertyData)
      });
      
      assertEquals(response.status, 400);
      
      const data = await response.json();
      assertEquals(data.error.code, 'VALIDATION_ERROR');
    });
  });
  
  describe('Authorization Security', () => {
    let user1Token: string;
    let user2Token: string;
    let user1PropertyId: string;
    
    beforeEach(async () => {
      // 2ã¤ã®ãƒ†ã‚¹ãƒˆãƒ¦ãƒ¼ã‚¶ãƒ¼ã‚’ä½œæˆ
      const user1Response = await fetch(`${baseUrl}/auth/register`, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          email: `auth-user1-${crypto.randomUUID()}@example.com`,
          password: 'User1Password123!',
          first_name: 'User1',
          last_name: 'Test'
        })
      });
      
      const user2Response = await fetch(`${baseUrl}/auth/register`, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          email: `auth-user2-${crypto.randomUUID()}@example.com`,
          password: 'User2Password123!',
          first_name: 'User2',
          last_name: 'Test'
        })
      });
      
      const user1Data = await user1Response.json();
      const user2Data = await user2Response.json();
      
      user1Token = user1Data.data.access_token;
      user2Token = user2Data.data.access_token;
      
      // User1ã®ç‰©ä»¶ã‚’ä½œæˆ
      const propertyData = {
        name: 'User1 Property',
        address: '123 User1 St',
        property_type: 'apartment',
        purchase_price: 250000,
        purchase_date: '2024-01-01T00:00:00Z'
      };
      
      const createResponse = await fetch(`${baseUrl}/properties/create`, {
        method: 'POST',
        headers: {
          'Authorization': `Bearer ${user1Token}`,
          'Content-Type': 'application/json'
        },
        body: JSON.stringify(propertyData)
      });
      
      const createData = await createResponse.json();
      user1PropertyId = createData.data.property.id;
    });
    
    it('should prevent unauthorized access to other users data', async () => {
      // User2ãŒUser1ã®ç‰©ä»¶ã«ã‚¢ã‚¯ã‚»ã‚¹ã—ã‚ˆã†ã¨ã™ã‚‹
      const response = await fetch(`${baseUrl}/properties/read/${user1PropertyId}`, {
        method: 'GET',
        headers: {
          'Authorization': `Bearer ${user2Token}`
        }
      });
      
      assertEquals(response.status, 404); // å­˜åœ¨ã—ãªã„ã‹ã®ã‚ˆã†ã«æ‰±ã†
    });
    
    it('should prevent unauthorized modification of other users data', async () => {
      const updateData = {
        name: 'Hacked Property Name'
      };
      
      const response = await fetch(`${baseUrl}/properties/update/${user1PropertyId}`, {
        method: 'PUT',
        headers: {
          'Authorization': `Bearer ${user2Token}`,
          'Content-Type': 'application/json'
        },
        body: JSON.stringify(updateData)
      });
      
      assertEquals(response.status, 404);
      
      // å…ƒã®ãƒ‡ãƒ¼ã‚¿ãŒå¤‰æ›´ã•ã‚Œã¦ã„ãªã„ã“ã¨ã‚’ç¢ºèª
      const checkResponse = await fetch(`${baseUrl}/properties/read/${user1PropertyId}`, {
        method: 'GET',
        headers: {
          'Authorization': `Bearer ${user1Token}`
        }
      });
      
      const checkData = await checkResponse.json();
      assertEquals(checkData.data.property.name, 'User1 Property');
    });
    
    it('should prevent unauthorized deletion of other users data', async () => {
      const response = await fetch(`${baseUrl}/properties/delete/${user1PropertyId}`, {
        method: 'DELETE',
        headers: {
          'Authorization': `Bearer ${user2Token}`
        }
      });
      
      assertEquals(response.status, 404);
      
      // ãƒ‡ãƒ¼ã‚¿ãŒå‰Šé™¤ã•ã‚Œã¦ã„ãªã„ã“ã¨ã‚’ç¢ºèª
      const checkResponse = await fetch(`${baseUrl}/properties/read/${user1PropertyId}`, {
        method: 'GET',
        headers: {
          'Authorization': `Bearer ${user1Token}`
        }
      });
      
      assertEquals(checkResponse.status, 200);
    });
  });
  
  describe('Rate Limiting Security', () => {
    let authToken: string;
    
    beforeEach(async () => {
      const registerResponse = await fetch(`${baseUrl}/auth/register`, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          email: `rate-limit-test-${crypto.randomUUID()}@example.com`,
          password: 'RateLimitPassword123!',
          first_name: 'RateLimit',
          last_name: 'Tester'
        })
      });
      
      const registerData = await registerResponse.json();
      authToken = registerData.data.access_token;
    });
    
    it('should enforce rate limits on API endpoints', async () => {
      const requests = [];
      
      // çŸ­æ™‚é–“ã§å¤§é‡ã®ãƒªã‚¯ã‚¨ã‚¹ãƒˆã‚’é€ä¿¡
      for (let i = 0; i < 100; i++) {
        requests.push(
          fetch(`${baseUrl}/properties/read`, {
            method: 'GET',
            headers: {
              'Authorization': `Bearer ${authToken}`
            }
          })
        );
      }
      
      const responses = await Promise.all(requests);
      
      // ä¸€éƒ¨ã®ãƒªã‚¯ã‚¨ã‚¹ãƒˆãŒãƒ¬ãƒ¼ãƒˆåˆ¶é™ã§ãƒ–ãƒ­ãƒƒã‚¯ã•ã‚Œã‚‹ã“ã¨ã‚’ç¢ºèª
      const rateLimitedResponses = responses.filter(r => r.status === 429);
      assertEquals(rateLimitedResponses.length > 0, true);
    });
  });
});
```


---

## âš¡ ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹ãƒ†ã‚¹ãƒˆå®Ÿè£…

### ğŸ“Š ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹ãƒ†ã‚¹ãƒˆæˆ¦ç•¥

ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹ãƒ†ã‚¹ãƒˆã¯ã€RichmanManage APIãŒå®Ÿéš›ã®é‹ç”¨ç’°å¢ƒã§æœŸå¾…ã•ã‚Œã‚‹è² è·ã«è€ãˆã‚‰ã‚Œã‚‹ã“ã¨ã‚’ä¿è¨¼ã—ã¾ã™ã€‚è² è·ãƒ†ã‚¹ãƒˆã€ã‚¹ãƒˆãƒ¬ã‚¹ãƒ†ã‚¹ãƒˆã€ã‚¹ãƒ‘ã‚¤ã‚¯ãƒ†ã‚¹ãƒˆã€è€ä¹…ãƒ†ã‚¹ãƒˆã‚’çµ„ã¿åˆã‚ã›ã‚‹ã“ã¨ã§ã€åŒ…æ‹¬çš„ãªãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹è©•ä¾¡ã‚’å®Ÿæ–½ã—ã¾ã™ã€‚

```typescript
// supabase/functions/tests/performance/load-test.ts
import { assertEquals, assert } from 'https://deno.land/std@0.208.0/testing/asserts.ts';
import { describe, it, beforeAll, afterAll } from 'https://deno.land/std@0.208.0/testing/bdd.ts';

interface PerformanceMetrics {
  totalRequests: number;
  successfulRequests: number;
  failedRequests: number;
  averageResponseTime: number;
  p95ResponseTime: number;
  p99ResponseTime: number;
  requestsPerSecond: number;
  errorRate: number;
}

class LoadTestRunner {
  private baseUrl: string;
  private authTokens: string[] = [];
  
  constructor(baseUrl: string) {
    this.baseUrl = baseUrl;
  }
  
  async setupTestUsers(count: number): Promise<void> {
    const userCreationPromises = [];
    
    for (let i = 0; i < count; i++) {
      userCreationPromises.push(this.createTestUser(i));
    }
    
    const tokens = await Promise.all(userCreationPromises);
    this.authTokens = tokens.filter(token => token !== null) as string[];
  }
  
  private async createTestUser(index: number): Promise<string | null> {
    try {
      const response = await fetch(`${this.baseUrl}/auth/register`, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          email: `load-test-user-${index}-${crypto.randomUUID()}@example.com`,
          password: 'LoadTestPassword123!',
          first_name: `LoadTest${index}`,
          last_name: 'User'
        })
      });
      
      if (response.ok) {
        const data = await response.json();
        return data.data.access_token;
      }
      return null;
    } catch (error) {
      console.error(`Failed to create test user ${index}:`, error);
      return null;
    }
  }
  
  async runLoadTest(
    endpoint: string,
    method: string,
    payload: any,
    concurrentUsers: number,
    requestsPerUser: number,
    testDurationSeconds: number
  ): Promise<PerformanceMetrics> {
    const startTime = Date.now();
    const endTime = startTime + (testDurationSeconds * 1000);
    const responseTimes: number[] = [];
    const results: { success: boolean; responseTime: number }[] = [];
    
    const userPromises = [];
    
    for (let userIndex = 0; userIndex < concurrentUsers; userIndex++) {
      const authToken = this.authTokens[userIndex % this.authTokens.length];
      userPromises.push(this.simulateUser(endpoint, method, payload, authToken, requestsPerUser, endTime, results, responseTimes));
    }
    
    await Promise.all(userPromises);
    
    return this.calculateMetrics(results, responseTimes, testDurationSeconds);
  }
  
  private async simulateUser(
    endpoint: string,
    method: string,
    payload: any,
    authToken: string,
    requestsPerUser: number,
    endTime: number,
    results: { success: boolean; responseTime: number }[],
    responseTimes: number[]
  ): Promise<void> {
    let requestCount = 0;
    
    while (Date.now() < endTime && requestCount < requestsPerUser) {
      const requestStart = Date.now();
      
      try {
        const response = await fetch(`${this.baseUrl}${endpoint}`, {
          method,
          headers: {
            'Authorization': `Bearer ${authToken}`,
            'Content-Type': 'application/json'
          },
          body: payload ? JSON.stringify(payload) : undefined
        });
        
        const responseTime = Date.now() - requestStart;
        responseTimes.push(responseTime);
        results.push({ success: response.ok, responseTime });
        
      } catch (error) {
        const responseTime = Date.now() - requestStart;
        responseTimes.push(responseTime);
        results.push({ success: false, responseTime });
      }
      
      requestCount++;
      
      // ãƒªã‚¯ã‚¨ã‚¹ãƒˆé–“ã®å°ã•ãªé…å»¶ï¼ˆå®Ÿéš›ã®ãƒ¦ãƒ¼ã‚¶ãƒ¼è¡Œå‹•ã‚’ã‚·ãƒŸãƒ¥ãƒ¬ãƒ¼ãƒˆï¼‰
      await new Promise(resolve => setTimeout(resolve, Math.random() * 100));
    }
  }
  
  private calculateMetrics(
    results: { success: boolean; responseTime: number }[],
    responseTimes: number[],
    testDurationSeconds: number
  ): PerformanceMetrics {
    const totalRequests = results.length;
    const successfulRequests = results.filter(r => r.success).length;
    const failedRequests = totalRequests - successfulRequests;
    
    const sortedResponseTimes = responseTimes.sort((a, b) => a - b);
    const averageResponseTime = responseTimes.reduce((sum, time) => sum + time, 0) / responseTimes.length;
    const p95Index = Math.floor(sortedResponseTimes.length * 0.95);
    const p99Index = Math.floor(sortedResponseTimes.length * 0.99);
    
    return {
      totalRequests,
      successfulRequests,
      failedRequests,
      averageResponseTime: Math.round(averageResponseTime),
      p95ResponseTime: sortedResponseTimes[p95Index] || 0,
      p99ResponseTime: sortedResponseTimes[p99Index] || 0,
      requestsPerSecond: Math.round(totalRequests / testDurationSeconds),
      errorRate: (failedRequests / totalRequests) * 100
    };
  }
  
  async cleanup(): Promise<void> {
    // ãƒ†ã‚¹ãƒˆãƒ¦ãƒ¼ã‚¶ãƒ¼ã®ã‚¯ãƒªãƒ¼ãƒ³ã‚¢ãƒƒãƒ—
    const cleanupPromises = this.authTokens.map(token => 
      fetch(`${this.baseUrl}/users/delete`, {
        method: 'DELETE',
        headers: {
          'Authorization': `Bearer ${token}`,
          'Content-Type': 'application/json'
        }
      }).catch(error => console.error('Cleanup error:', error))
    );
    
    await Promise.all(cleanupPromises);
  }
}

describe('API Performance Tests', () => {
  let loadTestRunner: LoadTestRunner;
  const baseUrl = 'http://localhost:54321/functions/v1';
  
  beforeAll(async () => {
    loadTestRunner = new LoadTestRunner(baseUrl);
    await loadTestRunner.setupTestUsers(50); // 50äººã®åŒæ™‚ãƒ¦ãƒ¼ã‚¶ãƒ¼ã‚’æº–å‚™
  });
  
  afterAll(async () => {
    await loadTestRunner.cleanup();
  });
  
  describe('Property API Load Tests', () => {
    it('should handle property creation under normal load', async () => {
      const propertyPayload = {
        name: 'Load Test Property',
        address: '123 Load Test St',
        property_type: 'apartment',
        purchase_price: 250000,
        purchase_date: '2024-01-01T00:00:00Z'
      };
      
      const metrics = await loadTestRunner.runLoadTest(
        '/properties/create',
        'POST',
        propertyPayload,
        10, // 10 concurrent users
        5,  // 5 requests per user
        30  // 30 seconds test duration
      );
      
      // ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹è¦ä»¶ã®æ¤œè¨¼
      assert(metrics.averageResponseTime < 200, `Average response time ${metrics.averageResponseTime}ms exceeds 200ms limit`);
      assert(metrics.p95ResponseTime < 500, `P95 response time ${metrics.p95ResponseTime}ms exceeds 500ms limit`);
      assert(metrics.errorRate < 1, `Error rate ${metrics.errorRate}% exceeds 1% limit`);
      assert(metrics.requestsPerSecond > 10, `RPS ${metrics.requestsPerSecond} below minimum 10 RPS`);
      
      console.log('Property Creation Load Test Results:', metrics);
    });
    
    it('should handle property search under high load', async () => {
      // äº‹å‰ã«ãƒ†ã‚¹ãƒˆãƒ‡ãƒ¼ã‚¿ã‚’ä½œæˆ
      const setupPromises = [];
      for (let i = 0; i < 100; i++) {
        const propertyPayload = {
          name: `Search Test Property ${i}`,
          address: `${i} Search Test St`,
          property_type: i % 2 === 0 ? 'apartment' : 'house',
          purchase_price: 200000 + (i * 1000),
          purchase_date: '2024-01-01T00:00:00Z'
        };
        
        setupPromises.push(
          fetch(`${baseUrl}/properties/create`, {
            method: 'POST',
            headers: {
              'Authorization': `Bearer ${loadTestRunner['authTokens'][0]}`,
              'Content-Type': 'application/json'
            },
            body: JSON.stringify(propertyPayload)
          })
        );
      }
      
      await Promise.all(setupPromises);
      
      const metrics = await loadTestRunner.runLoadTest(
        '/properties/search?query=Search&page=1&limit=20',
        'GET',
        null,
        25, // 25 concurrent users
        10, // 10 requests per user
        60  // 60 seconds test duration
      );
      
      // æ¤œç´¢APIã®ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹è¦ä»¶
      assert(metrics.averageResponseTime < 300, `Search average response time ${metrics.averageResponseTime}ms exceeds 300ms limit`);
      assert(metrics.p95ResponseTime < 800, `Search P95 response time ${metrics.p95ResponseTime}ms exceeds 800ms limit`);
      assert(metrics.errorRate < 0.5, `Search error rate ${metrics.errorRate}% exceeds 0.5% limit`);
      assert(metrics.requestsPerSecond > 20, `Search RPS ${metrics.requestsPerSecond} below minimum 20 RPS`);
      
      console.log('Property Search Load Test Results:', metrics);
    });
  });
  
  describe('Authentication Performance Tests', () => {
    it('should handle login requests under load', async () => {
      // ãƒ­ã‚°ã‚¤ãƒ³ç”¨ã®ãƒ†ã‚¹ãƒˆãƒ¦ãƒ¼ã‚¶ãƒ¼ã‚’äº‹å‰ä½œæˆ
      const testUsers = [];
      for (let i = 0; i < 20; i++) {
        const email = `login-test-${i}-${crypto.randomUUID()}@example.com`;
        const password = 'LoginTestPassword123!';
        
        await fetch(`${baseUrl}/auth/register`, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({
            email,
            password,
            first_name: `LoginTest${i}`,
            last_name: 'User'
          })
        });
        
        testUsers.push({ email, password });
      }
      
      // ãƒ­ã‚°ã‚¤ãƒ³è² è·ãƒ†ã‚¹ãƒˆ
      const loginPromises = [];
      const startTime = Date.now();
      
      for (let i = 0; i < 100; i++) {
        const user = testUsers[i % testUsers.length];
        loginPromises.push(
          fetch(`${baseUrl}/auth/login`, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify(user)
          }).then(response => ({
            success: response.ok,
            responseTime: Date.now() - startTime
          }))
        );
      }
      
      const results = await Promise.all(loginPromises);
      const totalTime = Date.now() - startTime;
      
      const successfulLogins = results.filter(r => r.success).length;
      const averageResponseTime = results.reduce((sum, r) => sum + r.responseTime, 0) / results.length;
      const loginRPS = results.length / (totalTime / 1000);
      
      // ãƒ­ã‚°ã‚¤ãƒ³ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹è¦ä»¶
      assert(averageResponseTime < 500, `Login average response time ${averageResponseTime}ms exceeds 500ms limit`);
      assert(successfulLogins / results.length > 0.99, `Login success rate ${successfulLogins / results.length} below 99%`);
      assert(loginRPS > 5, `Login RPS ${loginRPS} below minimum 5 RPS`);
      
      console.log('Login Performance Results:', {
        totalRequests: results.length,
        successfulLogins,
        averageResponseTime: Math.round(averageResponseTime),
        loginRPS: Math.round(loginRPS)
      });
    });
  });
  
  describe('Stress Tests', () => {
    it('should maintain stability under extreme load', async () => {
      const propertyPayload = {
        name: 'Stress Test Property',
        address: '999 Stress Test Ave',
        property_type: 'commercial',
        purchase_price: 1000000,
        purchase_date: '2024-01-01T00:00:00Z'
      };
      
      // æ¥µç«¯ãªè² è·ã§ã®ãƒ†ã‚¹ãƒˆ
      const metrics = await loadTestRunner.runLoadTest(
        '/properties/create',
        'POST',
        propertyPayload,
        50, // 50 concurrent users
        20, // 20 requests per user
        120 // 2 minutes test duration
      );
      
      // ã‚¹ãƒˆãƒ¬ã‚¹ãƒ†ã‚¹ãƒˆã®è¦ä»¶ï¼ˆé€šå¸¸ã‚ˆã‚Šç·©ã„åŸºæº–ï¼‰
      assert(metrics.averageResponseTime < 1000, `Stress test average response time ${metrics.averageResponseTime}ms exceeds 1000ms limit`);
      assert(metrics.errorRate < 5, `Stress test error rate ${metrics.errorRate}% exceeds 5% limit`);
      assert(metrics.requestsPerSecond > 5, `Stress test RPS ${metrics.requestsPerSecond} below minimum 5 RPS`);
      
      console.log('Stress Test Results:', metrics);
    });
  });
  
  describe('Spike Tests', () => {
    it('should handle sudden traffic spikes gracefully', async () => {
      // æ®µéšçš„ãªè² è·å¢—åŠ ã‚’ã‚·ãƒŸãƒ¥ãƒ¬ãƒ¼ãƒˆ
      const phases = [
        { users: 5, duration: 10 },   // ã‚¦ã‚©ãƒ¼ãƒ ã‚¢ãƒƒãƒ—
        { users: 50, duration: 30 },  // ã‚¹ãƒ‘ã‚¤ã‚¯
        { users: 10, duration: 20 }   // å›å¾©
      ];
      
      const allMetrics = [];
      
      for (const phase of phases) {
        const metrics = await loadTestRunner.runLoadTest(
          '/properties/read',
          'GET',
          null,
          phase.users,
          10,
          phase.duration
        );
        
        allMetrics.push({
          phase: `${phase.users} users`,
          ...metrics
        });
      }
      
      // ã‚¹ãƒ‘ã‚¤ã‚¯ãƒ†ã‚¹ãƒˆã®è©•ä¾¡
      const spikePhase = allMetrics[1]; // 50ãƒ¦ãƒ¼ã‚¶ãƒ¼ã®ãƒ•ã‚§ãƒ¼ã‚º
      assert(spikePhase.errorRate < 10, `Spike phase error rate ${spikePhase.errorRate}% exceeds 10% limit`);
      assert(spikePhase.averageResponseTime < 2000, `Spike phase response time ${spikePhase.averageResponseTime}ms exceeds 2000ms limit`);
      
      console.log('Spike Test Results:', allMetrics);
    });
  });
  
  describe('Endurance Tests', () => {
    it('should maintain performance over extended periods', async () => {
      const propertyPayload = {
        name: 'Endurance Test Property',
        address: '777 Endurance Test Blvd',
        property_type: 'house',
        purchase_price: 350000,
        purchase_date: '2024-01-01T00:00:00Z'
      };
      
      // é•·æ™‚é–“ã®è€ä¹…ãƒ†ã‚¹ãƒˆï¼ˆå®Ÿéš›ã®é‹ç”¨ã§ã¯æ•°æ™‚é–“ã€œæ•°æ—¥ï¼‰
      const metrics = await loadTestRunner.runLoadTest(
        '/properties/create',
        'POST',
        propertyPayload,
        15, // 15 concurrent users
        50, // 50 requests per user
        300 // 5 minutes test duration
      );
      
      // è€ä¹…ãƒ†ã‚¹ãƒˆã®è¦ä»¶
      assert(metrics.averageResponseTime < 400, `Endurance test average response time ${metrics.averageResponseTime}ms exceeds 400ms limit`);
      assert(metrics.errorRate < 2, `Endurance test error rate ${metrics.errorRate}% exceeds 2% limit`);
      assert(metrics.requestsPerSecond > 8, `Endurance test RPS ${metrics.requestsPerSecond} below minimum 8 RPS`);
      
      console.log('Endurance Test Results:', metrics);
    });
  });
});
```

### ğŸ“ˆ ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹ç›£è¦–å®Ÿè£…

```typescript
// supabase/functions/shared/middleware/performance-monitor.ts
export interface PerformanceMetrics {
  endpoint: string;
  method: string;
  responseTime: number;
  statusCode: number;
  userId?: string;
  timestamp: string;
  memoryUsage: number;
  cpuUsage: number;
}

export class PerformanceMonitor {
  private static metrics: PerformanceMetrics[] = [];
  private static readonly MAX_METRICS = 10000;
  
  static async trackRequest(
    req: Request,
    handler: (req: Request) => Promise<Response>
  ): Promise<Response> {
    const startTime = performance.now();
    const startMemory = this.getMemoryUsage();
    
    try {
      const response = await handler(req);
      const endTime = performance.now();
      const endMemory = this.getMemoryUsage();
      
      const metric: PerformanceMetrics = {
        endpoint: new URL(req.url).pathname,
        method: req.method,
        responseTime: Math.round(endTime - startTime),
        statusCode: response.status,
        timestamp: new Date().toISOString(),
        memoryUsage: endMemory - startMemory,
        cpuUsage: this.getCPUUsage()
      };
      
      // ãƒ¦ãƒ¼ã‚¶ãƒ¼IDã®æŠ½å‡ºï¼ˆèªè¨¼æ¸ˆã¿ãƒªã‚¯ã‚¨ã‚¹ãƒˆã®å ´åˆï¼‰
      const authHeader = req.headers.get('Authorization');
      if (authHeader) {
        try {
          const token = authHeader.substring(7);
          const payload = await this.decodeJWT(token);
          metric.userId = payload.sub;
        } catch (error) {
          // èªè¨¼ã‚¨ãƒ©ãƒ¼ã¯ç„¡è¦–
        }
      }
      
      this.addMetric(metric);
      
      // ãƒ¬ã‚¹ãƒãƒ³ã‚¹ãƒ˜ãƒƒãƒ€ãƒ¼ã«ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹æƒ…å ±ã‚’è¿½åŠ 
      response.headers.set('X-Response-Time', `${metric.responseTime}ms`);
      response.headers.set('X-Memory-Usage', `${metric.memoryUsage}MB`);
      
      return response;
    } catch (error) {
      const endTime = performance.now();
      
      const metric: PerformanceMetrics = {
        endpoint: new URL(req.url).pathname,
        method: req.method,
        responseTime: Math.round(endTime - startTime),
        statusCode: 500,
        timestamp: new Date().toISOString(),
        memoryUsage: this.getMemoryUsage() - startMemory,
        cpuUsage: this.getCPUUsage()
      };
      
      this.addMetric(metric);
      throw error;
    }
  }
  
  private static addMetric(metric: PerformanceMetrics): void {
    this.metrics.push(metric);
    
    // ãƒ¡ãƒˆãƒªã‚¯ã‚¹ã®æ•°ã‚’åˆ¶é™
    if (this.metrics.length > this.MAX_METRICS) {
      this.metrics = this.metrics.slice(-this.MAX_METRICS);
    }
    
    // ç•°å¸¸å€¤ã®æ¤œå‡ºã¨ã‚¢ãƒ©ãƒ¼ãƒˆ
    this.detectAnomalies(metric);
  }
  
  private static detectAnomalies(metric: PerformanceMetrics): void {
    // å¿œç­”æ™‚é–“ã®ç•°å¸¸æ¤œå‡º
    if (metric.responseTime > 5000) {
      this.sendAlert('HIGH_RESPONSE_TIME', {
        endpoint: metric.endpoint,
        responseTime: metric.responseTime,
        timestamp: metric.timestamp
      });
    }
    
    // ã‚¨ãƒ©ãƒ¼ç‡ã®ç•°å¸¸æ¤œå‡º
    const recentMetrics = this.metrics.slice(-100);
    const errorRate = recentMetrics.filter(m => m.statusCode >= 400).length / recentMetrics.length;
    
    if (errorRate > 0.1) { // 10%ä»¥ä¸Šã®ã‚¨ãƒ©ãƒ¼ç‡
      this.sendAlert('HIGH_ERROR_RATE', {
        errorRate: errorRate * 100,
        sampleSize: recentMetrics.length,
        timestamp: metric.timestamp
      });
    }
    
    // ãƒ¡ãƒ¢ãƒªä½¿ç”¨é‡ã®ç•°å¸¸æ¤œå‡º
    if (metric.memoryUsage > 100) { // 100MBä»¥ä¸Šã®ãƒ¡ãƒ¢ãƒªä½¿ç”¨
      this.sendAlert('HIGH_MEMORY_USAGE', {
        memoryUsage: metric.memoryUsage,
        endpoint: metric.endpoint,
        timestamp: metric.timestamp
      });
    }
  }
  
  private static async sendAlert(type: string, data: any): Promise<void> {
    try {
      // Slackã€Discordã€ãƒ¡ãƒ¼ãƒ«ç­‰ã¸ã®é€šçŸ¥å®Ÿè£…
      const alertPayload = {
        type,
        data,
        severity: this.getAlertSeverity(type),
        timestamp: new Date().toISOString()
      };
      
      // å¤–éƒ¨ç›£è¦–ã‚·ã‚¹ãƒ†ãƒ ã¸ã®é€ä¿¡
      await fetch(Deno.env.get('ALERT_WEBHOOK_URL')!, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(alertPayload)
      });
      
    } catch (error) {
      console.error('Failed to send alert:', error);
    }
  }
  
  private static getAlertSeverity(type: string): 'low' | 'medium' | 'high' | 'critical' {
    switch (type) {
      case 'HIGH_RESPONSE_TIME':
        return 'high';
      case 'HIGH_ERROR_RATE':
        return 'critical';
      case 'HIGH_MEMORY_USAGE':
        return 'medium';
      default:
        return 'low';
    }
  }
  
  static getMetrics(timeRange?: { start: string; end: string }): PerformanceMetrics[] {
    let filteredMetrics = this.metrics;
    
    if (timeRange) {
      const startTime = new Date(timeRange.start).getTime();
      const endTime = new Date(timeRange.end).getTime();
      
      filteredMetrics = this.metrics.filter(metric => {
        const metricTime = new Date(metric.timestamp).getTime();
        return metricTime >= startTime && metricTime <= endTime;
      });
    }
    
    return filteredMetrics;
  }
  
  static getAggregatedMetrics(timeRange?: { start: string; end: string }): any {
    const metrics = this.getMetrics(timeRange);
    
    if (metrics.length === 0) {
      return null;
    }
    
    const responseTimes = metrics.map(m => m.responseTime);
    const statusCodes = metrics.map(m => m.statusCode);
    
    responseTimes.sort((a, b) => a - b);
    
    return {
      totalRequests: metrics.length,
      averageResponseTime: Math.round(responseTimes.reduce((sum, time) => sum + time, 0) / responseTimes.length),
      medianResponseTime: responseTimes[Math.floor(responseTimes.length / 2)],
      p95ResponseTime: responseTimes[Math.floor(responseTimes.length * 0.95)],
      p99ResponseTime: responseTimes[Math.floor(responseTimes.length * 0.99)],
      errorRate: (statusCodes.filter(code => code >= 400).length / metrics.length) * 100,
      requestsPerSecond: this.calculateRPS(metrics),
      endpointBreakdown: this.getEndpointBreakdown(metrics),
      timeRange: timeRange || { start: metrics[0]?.timestamp, end: metrics[metrics.length - 1]?.timestamp }
    };
  }
  
  private static calculateRPS(metrics: PerformanceMetrics[]): number {
    if (metrics.length < 2) return 0;
    
    const firstTimestamp = new Date(metrics[0].timestamp).getTime();
    const lastTimestamp = new Date(metrics[metrics.length - 1].timestamp).getTime();
    const durationSeconds = (lastTimestamp - firstTimestamp) / 1000;
    
    return Math.round(metrics.length / durationSeconds);
  }
  
  private static getEndpointBreakdown(metrics: PerformanceMetrics[]): any {
    const breakdown: { [endpoint: string]: any } = {};
    
    metrics.forEach(metric => {
      if (!breakdown[metric.endpoint]) {
        breakdown[metric.endpoint] = {
          count: 0,
          totalResponseTime: 0,
          errors: 0
        };
      }
      
      breakdown[metric.endpoint].count++;
      breakdown[metric.endpoint].totalResponseTime += metric.responseTime;
      
      if (metric.statusCode >= 400) {
        breakdown[metric.endpoint].errors++;
      }
    });
    
    Object.keys(breakdown).forEach(endpoint => {
      const data = breakdown[endpoint];
      data.averageResponseTime = Math.round(data.totalResponseTime / data.count);
      data.errorRate = (data.errors / data.count) * 100;
      delete data.totalResponseTime;
    });
    
    return breakdown;
  }
  
  private static getMemoryUsage(): number {
    // Denoç’°å¢ƒã§ã®ãƒ¡ãƒ¢ãƒªä½¿ç”¨é‡å–å¾—
    return Math.round(Deno.memoryUsage().rss / 1024 / 1024); // MB
  }
  
  private static getCPUUsage(): number {
    // ç°¡ç•¥åŒ–ã•ã‚ŒãŸCPUä½¿ç”¨ç‡ï¼ˆå®Ÿéš›ã®å®Ÿè£…ã§ã¯è©³ç´°ãªè¨ˆæ¸¬ãŒå¿…è¦ï¼‰
    return Math.random() * 100; // ãƒ—ãƒ¬ãƒ¼ã‚¹ãƒ›ãƒ«ãƒ€ãƒ¼
  }
  
  private static async decodeJWT(token: string): Promise<any> {
    // JWT ãƒ‡ã‚³ãƒ¼ãƒ‰å®Ÿè£…ï¼ˆç°¡ç•¥åŒ–ï¼‰
    const parts = token.split('.');
    if (parts.length !== 3) throw new Error('Invalid JWT');
    
    const payload = JSON.parse(atob(parts[1]));
    return payload;
  }
}
```

---

## ğŸ“Š ç›£è¦–ãƒ»ãƒ­ã‚°ã‚·ã‚¹ãƒ†ãƒ å®Ÿè£…

### ğŸ” åŒ…æ‹¬çš„ãƒ­ã‚°ã‚·ã‚¹ãƒ†ãƒ 

```typescript
// supabase/functions/shared/utils/logger.ts
export enum LogLevel {
  DEBUG = 0,
  INFO = 1,
  WARN = 2,
  ERROR = 3,
  FATAL = 4
}

export interface LogEntry {
  timestamp: string;
  level: LogLevel;
  message: string;
  context?: any;
  userId?: string;
  requestId?: string;
  endpoint?: string;
  method?: string;
  statusCode?: number;
  responseTime?: number;
  error?: {
    name: string;
    message: string;
    stack?: string;
  };
  metadata?: any;
}

export class Logger {
  private static instance: Logger;
  private logLevel: LogLevel;
  private logBuffer: LogEntry[] = [];
  private readonly MAX_BUFFER_SIZE = 1000;
  
  private constructor() {
    this.logLevel = this.getLogLevelFromEnv();
    this.setupPeriodicFlush();
  }
  
  static getInstance(): Logger {
    if (!Logger.instance) {
      Logger.instance = new Logger();
    }
    return Logger.instance;
  }
  
  private getLogLevelFromEnv(): LogLevel {
    const envLevel = Deno.env.get('LOG_LEVEL')?.toUpperCase();
    switch (envLevel) {
      case 'DEBUG': return LogLevel.DEBUG;
      case 'INFO': return LogLevel.INFO;
      case 'WARN': return LogLevel.WARN;
      case 'ERROR': return LogLevel.ERROR;
      case 'FATAL': return LogLevel.FATAL;
      default: return LogLevel.INFO;
    }
  }
  
  debug(message: string, context?: any, metadata?: any): void {
    this.log(LogLevel.DEBUG, message, context, metadata);
  }
  
  info(message: string, context?: any, metadata?: any): void {
    this.log(LogLevel.INFO, message, context, metadata);
  }
  
  warn(message: string, context?: any, metadata?: any): void {
    this.log(LogLevel.WARN, message, context, metadata);
  }
  
  error(message: string, error?: Error, context?: any, metadata?: any): void {
    const errorInfo = error ? {
      name: error.name,
      message: error.message,
      stack: error.stack
    } : undefined;
    
    this.log(LogLevel.ERROR, message, context, metadata, errorInfo);
  }
  
  fatal(message: string, error?: Error, context?: any, metadata?: any): void {
    const errorInfo = error ? {
      name: error.name,
      message: error.message,
      stack: error.stack
    } : undefined;
    
    this.log(LogLevel.FATAL, message, context, metadata, errorInfo);
  }
  
  logRequest(
    req: Request,
    response: Response,
    responseTime: number,
    userId?: string,
    requestId?: string
  ): void {
    const logEntry: LogEntry = {
      timestamp: new Date().toISOString(),
      level: response.status >= 400 ? LogLevel.ERROR : LogLevel.INFO,
      message: `${req.method} ${new URL(req.url).pathname}`,
      userId,
      requestId,
      endpoint: new URL(req.url).pathname,
      method: req.method,
      statusCode: response.status,
      responseTime,
      metadata: {
        userAgent: req.headers.get('User-Agent'),
        referer: req.headers.get('Referer'),
        ip: req.headers.get('X-Forwarded-For') || req.headers.get('X-Real-IP')
      }
    };
    
    this.addToBuffer(logEntry);
  }
  
  private log(
    level: LogLevel,
    message: string,
    context?: any,
    metadata?: any,
    error?: any
  ): void {
    if (level < this.logLevel) {
      return;
    }
    
    const logEntry: LogEntry = {
      timestamp: new Date().toISOString(),
      level,
      message,
      context,
      metadata,
      error
    };
    
    this.addToBuffer(logEntry);
    
    // ã‚³ãƒ³ã‚½ãƒ¼ãƒ«å‡ºåŠ›ï¼ˆé–‹ç™ºç’°å¢ƒï¼‰
    if (Deno.env.get('ENVIRONMENT') === 'development') {
      this.consoleLog(logEntry);
    }
  }
  
  private addToBuffer(logEntry: LogEntry): void {
    this.logBuffer.push(logEntry);
    
    if (this.logBuffer.length >= this.MAX_BUFFER_SIZE) {
      this.flushLogs();
    }
  }
  
  private consoleLog(logEntry: LogEntry): void {
    const levelName = LogLevel[logEntry.level];
    const timestamp = logEntry.timestamp;
    const message = logEntry.message;
    
    const logMessage = `[${timestamp}] ${levelName}: ${message}`;
    
    switch (logEntry.level) {
      case LogLevel.DEBUG:
        console.debug(logMessage, logEntry.context);
        break;
      case LogLevel.INFO:
        console.info(logMessage, logEntry.context);
        break;
      case LogLevel.WARN:
        console.warn(logMessage, logEntry.context);
        break;
      case LogLevel.ERROR:
      case LogLevel.FATAL:
        console.error(logMessage, logEntry.error, logEntry.context);
        break;
    }
  }
  
  private setupPeriodicFlush(): void {
    // 30ç§’ã”ã¨ã«ãƒ­ã‚°ã‚’ãƒ•ãƒ©ãƒƒã‚·ãƒ¥
    setInterval(() => {
      if (this.logBuffer.length > 0) {
        this.flushLogs();
      }
    }, 30000);
  }
  
  private async flushLogs(): Promise<void> {
    if (this.logBuffer.length === 0) {
      return;
    }
    
    const logsToFlush = [...this.logBuffer];
    this.logBuffer = [];
    
    try {
      // å¤–éƒ¨ãƒ­ã‚°ã‚µãƒ¼ãƒ“ã‚¹ã¸ã®é€ä¿¡
      await this.sendToLogService(logsToFlush);
      
      // ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹ã¸ã®ä¿å­˜ï¼ˆé‡è¦ãªãƒ­ã‚°ã®ã¿ï¼‰
      const importantLogs = logsToFlush.filter(log => 
        log.level >= LogLevel.WARN || 
        log.statusCode && log.statusCode >= 400
      );
      
      if (importantLogs.length > 0) {
        await this.saveToDatabase(importantLogs);
      }
      
    } catch (error) {
      console.error('Failed to flush logs:', error);
      // ãƒ­ã‚°é€ä¿¡ã«å¤±æ•—ã—ãŸå ´åˆã€ãƒãƒƒãƒ•ã‚¡ã«æˆ»ã™
      this.logBuffer.unshift(...logsToFlush);
    }
  }
  
  private async sendToLogService(logs: LogEntry[]): Promise<void> {
    const logServiceUrl = Deno.env.get('LOG_SERVICE_URL');
    if (!logServiceUrl) {
      return;
    }
    
    const payload = {
      service: 'richman-manage-api',
      environment: Deno.env.get('ENVIRONMENT') || 'development',
      logs: logs
    };
    
    await fetch(logServiceUrl, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        'Authorization': `Bearer ${Deno.env.get('LOG_SERVICE_TOKEN')}`
      },
      body: JSON.stringify(payload)
    });
  }
  
  private async saveToDatabase(logs: LogEntry[]): Promise<void> {
    const { createClient } = await import('https://esm.sh/@supabase/supabase-js@2');
    const supabase = createClient(
      Deno.env.get('SUPABASE_URL')!,
      Deno.env.get('SUPABASE_SERVICE_ROLE_KEY')!
    );
    
    const dbLogs = logs.map(log => ({
      timestamp: log.timestamp,
      level: LogLevel[log.level],
      message: log.message,
      context: log.context,
      user_id: log.userId,
      request_id: log.requestId,
      endpoint: log.endpoint,
      method: log.method,
      status_code: log.statusCode,
      response_time: log.responseTime,
      error_name: log.error?.name,
      error_message: log.error?.message,
      error_stack: log.error?.stack,
      metadata: log.metadata
    }));
    
    await supabase.from('api_logs').insert(dbLogs);
  }
  
  async searchLogs(criteria: {
    startTime?: string;
    endTime?: string;
    level?: LogLevel;
    userId?: string;
    endpoint?: string;
    limit?: number;
  }): Promise<LogEntry[]> {
    const { createClient } = await import('https://esm.sh/@supabase/supabase-js@2');
    const supabase = createClient(
      Deno.env.get('SUPABASE_URL')!,
      Deno.env.get('SUPABASE_SERVICE_ROLE_KEY')!
    );
    
    let query = supabase
      .from('api_logs')
      .select('*')
      .order('timestamp', { ascending: false });
    
    if (criteria.startTime) {
      query = query.gte('timestamp', criteria.startTime);
    }
    
    if (criteria.endTime) {
      query = query.lte('timestamp', criteria.endTime);
    }
    
    if (criteria.level !== undefined) {
      query = query.eq('level', LogLevel[criteria.level]);
    }
    
    if (criteria.userId) {
      query = query.eq('user_id', criteria.userId);
    }
    
    if (criteria.endpoint) {
      query = query.eq('endpoint', criteria.endpoint);
    }
    
    if (criteria.limit) {
      query = query.limit(criteria.limit);
    }
    
    const { data, error } = await query;
    
    if (error) {
      throw error;
    }
    
    return data?.map(row => ({
      timestamp: row.timestamp,
      level: LogLevel[row.level as keyof typeof LogLevel],
      message: row.message,
      context: row.context,
      userId: row.user_id,
      requestId: row.request_id,
      endpoint: row.endpoint,
      method: row.method,
      statusCode: row.status_code,
      responseTime: row.response_time,
      error: row.error_name ? {
        name: row.error_name,
        message: row.error_message,
        stack: row.error_stack
      } : undefined,
      metadata: row.metadata
    })) || [];
  }
  
  async getLogStatistics(timeRange: { start: string; end: string }): Promise<any> {
    const { createClient } = await import('https://esm.sh/@supabase/supabase-js@2');
    const supabase = createClient(
      Deno.env.get('SUPABASE_URL')!,
      Deno.env.get('SUPABASE_SERVICE_ROLE_KEY')!
    );
    
    const { data, error } = await supabase
      .from('api_logs')
      .select('level, status_code, endpoint, response_time')
      .gte('timestamp', timeRange.start)
      .lte('timestamp', timeRange.end);
    
    if (error) {
      throw error;
    }
    
    const stats = {
      totalLogs: data.length,
      levelBreakdown: {} as { [key: string]: number },
      statusCodeBreakdown: {} as { [key: number]: number },
      endpointBreakdown: {} as { [key: string]: number },
      averageResponseTime: 0,
      errorRate: 0
    };
    
    let totalResponseTime = 0;
    let errorCount = 0;
    
    data.forEach(log => {
      // ãƒ¬ãƒ™ãƒ«åˆ¥é›†è¨ˆ
      stats.levelBreakdown[log.level] = (stats.levelBreakdown[log.level] || 0) + 1;
      
      // ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹ã‚³ãƒ¼ãƒ‰åˆ¥é›†è¨ˆ
      if (log.status_code) {
        stats.statusCodeBreakdown[log.status_code] = (stats.statusCodeBreakdown[log.status_code] || 0) + 1;
        
        if (log.status_code >= 400) {
          errorCount++;
        }
      }
      
      // ã‚¨ãƒ³ãƒ‰ãƒã‚¤ãƒ³ãƒˆåˆ¥é›†è¨ˆ
      if (log.endpoint) {
        stats.endpointBreakdown[log.endpoint] = (stats.endpointBreakdown[log.endpoint] || 0) + 1;
      }
      
      // ãƒ¬ã‚¹ãƒãƒ³ã‚¹æ™‚é–“é›†è¨ˆ
      if (log.response_time) {
        totalResponseTime += log.response_time;
      }
    });
    
    stats.averageResponseTime = data.length > 0 ? Math.round(totalResponseTime / data.length) : 0;
    stats.errorRate = data.length > 0 ? (errorCount / data.length) * 100 : 0;
    
    return stats;
  }
}

// ãƒ­ã‚°ãƒŸãƒ‰ãƒ«ã‚¦ã‚§ã‚¢
export async function logMiddleware(
  req: Request,
  handler: (req: Request) => Promise<Response>
): Promise<Response> {
  const logger = Logger.getInstance();
  const requestId = crypto.randomUUID();
  const startTime = performance.now();
  
  try {
    const response = await handler(req);
    const responseTime = Math.round(performance.now() - startTime);
    
    // ãƒ¦ãƒ¼ã‚¶ãƒ¼IDã®æŠ½å‡º
    let userId: string | undefined;
    const authHeader = req.headers.get('Authorization');
    if (authHeader) {
      try {
        const token = authHeader.substring(7);
        const payload = JSON.parse(atob(token.split('.')[1]));
        userId = payload.sub;
      } catch (error) {
        // èªè¨¼ã‚¨ãƒ©ãƒ¼ã¯ç„¡è¦–
      }
    }
    
    logger.logRequest(req, response, responseTime, userId, requestId);
    
    // ãƒ¬ã‚¹ãƒãƒ³ã‚¹ãƒ˜ãƒƒãƒ€ãƒ¼ã«ãƒªã‚¯ã‚¨ã‚¹ãƒˆIDã‚’è¿½åŠ 
    response.headers.set('X-Request-ID', requestId);
    
    return response;
  } catch (error) {
    const responseTime = Math.round(performance.now() - startTime);
    
    logger.error(
      `Request failed: ${req.method} ${new URL(req.url).pathname}`,
      error,
      { requestId, responseTime }
    );
    
    throw error;
  }
}
```

---

## ğŸš€ CI/CDçµ±åˆã¨ãƒ‡ãƒ—ãƒ­ã‚¤ãƒ¡ãƒ³ãƒˆ

### ğŸ”„ GitHub Actions ãƒ¯ãƒ¼ã‚¯ãƒ•ãƒ­ãƒ¼

```yaml
# .github/workflows/api-ci-cd.yml
name: RichmanManage API CI/CD

on:
  push:
    branches: [ main, develop ]
    paths:
      - 'supabase/functions/**'
      - '.github/workflows/api-ci-cd.yml'
  pull_request:
    branches: [ main ]
    paths:
      - 'supabase/functions/**'

env:
  SUPABASE_ACCESS_TOKEN: ${{ secrets.SUPABASE_ACCESS_TOKEN }}
  SUPABASE_PROJECT_ID: ${{ secrets.SUPABASE_PROJECT_ID }}
  SUPABASE_URL: ${{ secrets.SUPABASE_URL }}
  SUPABASE_ANON_KEY: ${{ secrets.SUPABASE_ANON_KEY }}
  SUPABASE_SERVICE_ROLE_KEY: ${{ secrets.SUPABASE_SERVICE_ROLE_KEY }}

jobs:
  lint-and-format:
    name: Lint and Format Check
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Deno
        uses: denoland/setup-deno@v1
        with:
          deno-version: v1.40.x

      - name: Cache Deno dependencies
        uses: actions/cache@v3
        with:
          path: ~/.cache/deno
          key: ${{ runner.os }}-deno-${{ hashFiles('**/deps.ts') }}
          restore-keys: |
            ${{ runner.os }}-deno-

      - name: Lint code
        run: |
          cd supabase/functions
          deno lint --rules-exclude=no-explicit-any

      - name: Format check
        run: |
          cd supabase/functions
          deno fmt --check

      - name: Type check
        run: |
          cd supabase/functions
          find . -name "*.ts" -exec deno check {} \;

  unit-tests:
    name: Unit Tests
    runs-on: ubuntu-latest
    needs: lint-and-format
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Deno
        uses: denoland/setup-deno@v1
        with:
          deno-version: v1.40.x

      - name: Cache Deno dependencies
        uses: actions/cache@v3
        with:
          path: ~/.cache/deno
          key: ${{ runner.os }}-deno-${{ hashFiles('**/deps.ts') }}
          restore-keys: |
            ${{ runner.os }}-deno-

      - name: Run unit tests
        run: |
          cd supabase/functions
          deno test --allow-all tests/unit/ --coverage=coverage/

      - name: Generate coverage report
        run: |
          cd supabase/functions
          deno coverage coverage/ --lcov --output=coverage.lcov

      - name: Upload coverage to Codecov
        uses: codecov/codecov-action@v3
        with:
          file: ./supabase/functions/coverage.lcov
          flags: unit-tests
          name: unit-test-coverage

  security-scan:
    name: Security Scan
    runs-on: ubuntu-latest
    needs: lint-and-format
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Deno
        uses: denoland/setup-deno@v1
        with:
          deno-version: v1.40.x

      - name: Security audit
        run: |
          cd supabase/functions
          # Denoã®ä¾å­˜é–¢ä¿‚ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£ãƒã‚§ãƒƒã‚¯
          deno info --json | jq '.modules[] | select(.specifier | contains("https://")) | .specifier' | sort | uniq > deps.txt
          
          # æ—¢çŸ¥ã®è„†å¼±æ€§ãƒã‚§ãƒƒã‚¯ï¼ˆã‚«ã‚¹ã‚¿ãƒ ã‚¹ã‚¯ãƒªãƒ—ãƒˆï¼‰
          echo "Checking for known vulnerabilities..."
          
      - name: SAST with Semgrep
        uses: returntocorp/semgrep-action@v1
        with:
          config: >-
            p/security-audit
            p/secrets
            p/typescript

  integration-tests:
    name: Integration Tests
    runs-on: ubuntu-latest
    needs: [unit-tests, security-scan]
    services:
      postgres:
        image: postgres:15
        env:
          POSTGRES_PASSWORD: postgres
          POSTGRES_DB: test_db
        options: >-
          --health-cmd pg_isready
          --health-interval 10s
          --health-timeout 5s
          --health-retries 5
        ports:
          - 5432:5432

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Deno
        uses: denoland/setup-deno@v1
        with:
          deno-version: v1.40.x

      - name: Setup Supabase CLI
        uses: supabase/setup-cli@v1
        with:
          version: latest

      - name: Start Supabase local development
        run: |
          supabase start
          supabase db reset

      - name: Deploy functions to local Supabase
        run: |
          supabase functions deploy --no-verify-jwt

      - name: Wait for services to be ready
        run: |
          timeout 60 bash -c 'until curl -f http://localhost:54321/health; do sleep 2; done'

      - name: Run integration tests
        env:
          SUPABASE_URL: http://localhost:54321
          SUPABASE_ANON_KEY: ${{ secrets.SUPABASE_ANON_KEY }}
        run: |
          cd supabase/functions
          deno test --allow-all tests/integration/ --coverage=coverage-integration/

      - name: Generate integration coverage report
        run: |
          cd supabase/functions
          deno coverage coverage-integration/ --lcov --output=coverage-integration.lcov

      - name: Upload integration coverage
        uses: codecov/codecov-action@v3
        with:
          file: ./supabase/functions/coverage-integration.lcov
          flags: integration-tests
          name: integration-test-coverage

      - name: Stop Supabase
        run: supabase stop

  performance-tests:
    name: Performance Tests
    runs-on: ubuntu-latest
    needs: integration-tests
    if: github.ref == 'refs/heads/main'
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Deno
        uses: denoland/setup-deno@v1
        with:
          deno-version: v1.40.x

      - name: Setup Supabase CLI
        uses: supabase/setup-cli@v1
        with:
          version: latest

      - name: Start Supabase local development
        run: |
          supabase start
          supabase db reset

      - name: Deploy functions to local Supabase
        run: |
          supabase functions deploy --no-verify-jwt

      - name: Run performance tests
        env:
          SUPABASE_URL: http://localhost:54321
          SUPABASE_ANON_KEY: ${{ secrets.SUPABASE_ANON_KEY }}
        run: |
          cd supabase/functions
          deno test --allow-all tests/performance/ --reporter=json > performance-results.json

      - name: Analyze performance results
        run: |
          cd supabase/functions
          # ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹çµæœã®åˆ†æã¨ãƒ¬ãƒãƒ¼ãƒˆç”Ÿæˆ
          deno run --allow-all scripts/analyze-performance.ts performance-results.json

      - name: Upload performance report
        uses: actions/upload-artifact@v3
        with:
          name: performance-report
          path: supabase/functions/performance-report.html

      - name: Stop Supabase
        run: supabase stop

  deploy-staging:
    name: Deploy to Staging
    runs-on: ubuntu-latest
    needs: [integration-tests]
    if: github.ref == 'refs/heads/develop'
    environment: staging
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Supabase CLI
        uses: supabase/setup-cli@v1
        with:
          version: latest

      - name: Deploy to Supabase Staging
        env:
          SUPABASE_ACCESS_TOKEN: ${{ secrets.SUPABASE_STAGING_ACCESS_TOKEN }}
          SUPABASE_PROJECT_ID: ${{ secrets.SUPABASE_STAGING_PROJECT_ID }}
        run: |
          supabase functions deploy --project-ref $SUPABASE_PROJECT_ID

      - name: Run smoke tests on staging
        env:
          STAGING_API_URL: ${{ secrets.STAGING_API_URL }}
          STAGING_API_KEY: ${{ secrets.STAGING_API_KEY }}
        run: |
          cd supabase/functions
          deno test --allow-all tests/smoke/ --env=staging

      - name: Notify deployment success
        uses: 8398a7/action-slack@v3
        with:
          status: success
          channel: '#deployments'
          text: 'API deployed to staging successfully! ğŸš€'
        env:
          SLACK_WEBHOOK_URL: ${{ secrets.SLACK_WEBHOOK_URL }}

  deploy-production:
    name: Deploy to Production
    runs-on: ubuntu-latest
    needs: [performance-tests]
    if: github.ref == 'refs/heads/main'
    environment: production
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Supabase CLI
        uses: supabase/setup-cli@v1
        with:
          version: latest

      - name: Deploy to Supabase Production
        env:
          SUPABASE_ACCESS_TOKEN: ${{ secrets.SUPABASE_PRODUCTION_ACCESS_TOKEN }}
          SUPABASE_PROJECT_ID: ${{ secrets.SUPABASE_PRODUCTION_PROJECT_ID }}
        run: |
          supabase functions deploy --project-ref $SUPABASE_PROJECT_ID

      - name: Run production health checks
        env:
          PRODUCTION_API_URL: ${{ secrets.PRODUCTION_API_URL }}
          PRODUCTION_API_KEY: ${{ secrets.PRODUCTION_API_KEY }}
        run: |
          cd supabase/functions
          deno test --allow-all tests/health/ --env=production

      - name: Update deployment status
        run: |
          # ãƒ‡ãƒ—ãƒ­ã‚¤ãƒ¡ãƒ³ãƒˆçŠ¶æ³ã‚’ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹ãƒšãƒ¼ã‚¸ã«æ›´æ–°
          curl -X POST "${{ secrets.STATUS_PAGE_WEBHOOK }}" \
            -H "Content-Type: application/json" \
            -d '{
              "component": "api",
              "status": "operational",
              "message": "API deployment completed successfully"
            }'

      - name: Notify deployment success
        uses: 8398a7/action-slack@v3
        with:
          status: success
          channel: '#deployments'
          text: 'API deployed to production successfully! ğŸ‰'
        env:
          SLACK_WEBHOOK_URL: ${{ secrets.SLACK_WEBHOOK_URL }}

  rollback:
    name: Rollback on Failure
    runs-on: ubuntu-latest
    needs: [deploy-production]
    if: failure()
    environment: production
    steps:
      - name: Checkout previous version
        uses: actions/checkout@v4
        with:
          ref: ${{ github.event.before }}

      - name: Setup Supabase CLI
        uses: supabase/setup-cli@v1
        with:
          version: latest

      - name: Rollback to previous version
        env:
          SUPABASE_ACCESS_TOKEN: ${{ secrets.SUPABASE_PRODUCTION_ACCESS_TOKEN }}
          SUPABASE_PROJECT_ID: ${{ secrets.SUPABASE_PRODUCTION_PROJECT_ID }}
        run: |
          supabase functions deploy --project-ref $SUPABASE_PROJECT_ID

      - name: Verify rollback
        env:
          PRODUCTION_API_URL: ${{ secrets.PRODUCTION_API_URL }}
          PRODUCTION_API_KEY: ${{ secrets.PRODUCTION_API_KEY }}
        run: |
          cd supabase/functions
          deno test --allow-all tests/health/ --env=production

      - name: Notify rollback
        uses: 8398a7/action-slack@v3
        with:
          status: failure
          channel: '#alerts'
          text: 'Production deployment failed. Rollback completed. ğŸš¨'
        env:
          SLACK_WEBHOOK_URL: ${{ secrets.SLACK_WEBHOOK_URL }}
```

### ğŸ“Š å“è³ªã‚²ãƒ¼ãƒˆè¨­å®š

```typescript
// scripts/quality-gates.ts
interface QualityMetrics {
  testCoverage: number;
  performanceScore: number;
  securityScore: number;
  codeQualityScore: number;
  errorRate: number;
  responseTime: number;
}

interface QualityGate {
  name: string;
  threshold: number;
  operator: 'gte' | 'lte' | 'eq';
  critical: boolean;
}

const QUALITY_GATES: QualityGate[] = [
  { name: 'testCoverage', threshold: 90, operator: 'gte', critical: true },
  { name: 'performanceScore', threshold: 85, operator: 'gte', critical: true },
  { name: 'securityScore', threshold: 95, operator: 'gte', critical: true },
  { name: 'codeQualityScore', threshold: 80, operator: 'gte', critical: false },
  { name: 'errorRate', threshold: 1, operator: 'lte', critical: true },
  { name: 'responseTime', threshold: 200, operator: 'lte', critical: true }
];

export class QualityGateValidator {
  static validate(metrics: QualityMetrics): { passed: boolean; failures: string[] } {
    const failures: string[] = [];
    
    for (const gate of QUALITY_GATES) {
      const value = metrics[gate.name as keyof QualityMetrics];
      let passed = false;
      
      switch (gate.operator) {
        case 'gte':
          passed = value >= gate.threshold;
          break;
        case 'lte':
          passed = value <= gate.threshold;
          break;
        case 'eq':
          passed = value === gate.threshold;
          break;
      }
      
      if (!passed) {
        const severity = gate.critical ? 'CRITICAL' : 'WARNING';
        failures.push(`${severity}: ${gate.name} (${value}) ${gate.operator} ${gate.threshold}`);
      }
    }
    
    const criticalFailures = failures.filter(f => f.startsWith('CRITICAL'));
    return {
      passed: criticalFailures.length === 0,
      failures
    };
  }
  
  static async collectMetrics(): Promise<QualityMetrics> {
    // ãƒ†ã‚¹ãƒˆã‚«ãƒãƒ¬ãƒƒã‚¸ã®å–å¾—
    const testCoverage = await this.getTestCoverage();
    
    // ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹ã‚¹ã‚³ã‚¢ã®è¨ˆç®—
    const performanceScore = await this.calculatePerformanceScore();
    
    // ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£ã‚¹ã‚³ã‚¢ã®è¨ˆç®—
    const securityScore = await this.calculateSecurityScore();
    
    // ã‚³ãƒ¼ãƒ‰å“è³ªã‚¹ã‚³ã‚¢ã®è¨ˆç®—
    const codeQualityScore = await this.calculateCodeQualityScore();
    
    // ã‚¨ãƒ©ãƒ¼ç‡ã®å–å¾—
    const errorRate = await this.getErrorRate();
    
    // ãƒ¬ã‚¹ãƒãƒ³ã‚¹æ™‚é–“ã®å–å¾—
    const responseTime = await this.getAverageResponseTime();
    
    return {
      testCoverage,
      performanceScore,
      securityScore,
      codeQualityScore,
      errorRate,
      responseTime
    };
  }
  
  private static async getTestCoverage(): Promise<number> {
    try {
      const coverageFile = await Deno.readTextFile('coverage.lcov');
      const lines = coverageFile.split('\n');
      
      let totalLines = 0;
      let coveredLines = 0;
      
      for (const line of lines) {
        if (line.startsWith('LF:')) {
          totalLines += parseInt(line.split(':')[1]);
        } else if (line.startsWith('LH:')) {
          coveredLines += parseInt(line.split(':')[1]);
        }
      }
      
      return totalLines > 0 ? (coveredLines / totalLines) * 100 : 0;
    } catch (error) {
      console.error('Failed to read coverage file:', error);
      return 0;
    }
  }
  
  private static async calculatePerformanceScore(): Promise<number> {
    try {
      const performanceFile = await Deno.readTextFile('performance-results.json');
      const results = JSON.parse(performanceFile);
      
      // ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹ã‚¹ã‚³ã‚¢ã®è¨ˆç®—ãƒ­ã‚¸ãƒƒã‚¯
      const avgResponseTime = results.averageResponseTime || 0;
      const errorRate = results.errorRate || 0;
      const throughput = results.requestsPerSecond || 0;
      
      // ã‚¹ã‚³ã‚¢è¨ˆç®—ï¼ˆ0-100ï¼‰
      let score = 100;
      
      // ãƒ¬ã‚¹ãƒãƒ³ã‚¹æ™‚é–“ãƒšãƒŠãƒ«ãƒ†ã‚£
      if (avgResponseTime > 200) {
        score -= Math.min(50, (avgResponseTime - 200) / 10);
      }
      
      // ã‚¨ãƒ©ãƒ¼ç‡ãƒšãƒŠãƒ«ãƒ†ã‚£
      score -= errorRate * 10;
      
      // ã‚¹ãƒ«ãƒ¼ãƒ—ãƒƒãƒˆãƒœãƒ¼ãƒŠã‚¹
      if (throughput > 50) {
        score += Math.min(10, (throughput - 50) / 10);
      }
      
      return Math.max(0, Math.min(100, score));
    } catch (error) {
      console.error('Failed to calculate performance score:', error);
      return 0;
    }
  }
  
  private static async calculateSecurityScore(): Promise<number> {
    try {
      // ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£ã‚¹ã‚­ãƒ£ãƒ³çµæœã®èª­ã¿è¾¼ã¿
      const securityFile = await Deno.readTextFile('security-scan-results.json');
      const results = JSON.parse(securityFile);
      
      let score = 100;
      
      // è„†å¼±æ€§ã«ã‚ˆã‚‹ãƒšãƒŠãƒ«ãƒ†ã‚£
      const criticalVulns = results.vulnerabilities?.critical || 0;
      const highVulns = results.vulnerabilities?.high || 0;
      const mediumVulns = results.vulnerabilities?.medium || 0;
      
      score -= criticalVulns * 25;
      score -= highVulns * 10;
      score -= mediumVulns * 5;
      
      return Math.max(0, score);
    } catch (error) {
      console.error('Failed to calculate security score:', error);
      return 0;
    }
  }
  
  private static async calculateCodeQualityScore(): Promise<number> {
    try {
      // ESLintçµæœã®èª­ã¿è¾¼ã¿
      const lintFile = await Deno.readTextFile('lint-results.json');
      const results = JSON.parse(lintFile);
      
      let score = 100;
      
      for (const file of results) {
        score -= file.errorCount * 5;
        score -= file.warningCount * 2;
      }
      
      return Math.max(0, score);
    } catch (error) {
      console.error('Failed to calculate code quality score:', error);
      return 0;
    }
  }
  
  private static async getErrorRate(): Promise<number> {
    // æœ€æ–°ã®ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹ãƒ†ã‚¹ãƒˆçµæœã‹ã‚‰ã‚¨ãƒ©ãƒ¼ç‡ã‚’å–å¾—
    try {
      const performanceFile = await Deno.readTextFile('performance-results.json');
      const results = JSON.parse(performanceFile);
      return results.errorRate || 0;
    } catch (error) {
      return 0;
    }
  }
  
  private static async getAverageResponseTime(): Promise<number> {
    // æœ€æ–°ã®ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹ãƒ†ã‚¹ãƒˆçµæœã‹ã‚‰ãƒ¬ã‚¹ãƒãƒ³ã‚¹æ™‚é–“ã‚’å–å¾—
    try {
      const performanceFile = await Deno.readTextFile('performance-results.json');
      const results = JSON.parse(performanceFile);
      return results.averageResponseTime || 0;
    } catch (error) {
      return 0;
    }
  }
}

// ãƒ¡ã‚¤ãƒ³å®Ÿè¡Œ
if (import.meta.main) {
  const metrics = await QualityGateValidator.collectMetrics();
  const validation = QualityGateValidator.validate(metrics);
  
  console.log('Quality Metrics:', metrics);
  console.log('Quality Gate Result:', validation);
  
  if (!validation.passed) {
    console.error('Quality gates failed:');
    validation.failures.forEach(failure => console.error(`  - ${failure}`));
    Deno.exit(1);
  } else {
    console.log('All quality gates passed! âœ…');
    Deno.exit(0);
  }
}
```

---

## ğŸ“ˆ ç¶™ç¶šçš„å“è³ªæ”¹å–„

### ğŸ”„ å“è³ªæ”¹å–„ã‚µã‚¤ã‚¯ãƒ«

ç¶™ç¶šçš„å“è³ªæ”¹å–„ã¯ã€RichmanManage APIã®é•·æœŸçš„ãªæˆåŠŸã‚’ä¿è¨¼ã™ã‚‹é‡è¦ãªãƒ—ãƒ­ã‚»ã‚¹ã§ã™ã€‚å®šæœŸçš„ãªå“è³ªè©•ä¾¡ã€ãƒ•ã‚£ãƒ¼ãƒ‰ãƒãƒƒã‚¯åé›†ã€æ”¹å–„å®Ÿè£…ã®ã‚µã‚¤ã‚¯ãƒ«ã‚’ç¢ºç«‹ã™ã‚‹ã“ã¨ã§ã€å¸¸ã«æœ€é«˜æ°´æº–ã®å“è³ªã‚’ç¶­æŒã—ã¾ã™ã€‚

```typescript
// scripts/quality-improvement-cycle.ts
interface QualityTrend {
  date: string;
  metrics: QualityMetrics;
  issues: QualityIssue[];
  improvements: QualityImprovement[];
}

interface QualityIssue {
  id: string;
  severity: 'low' | 'medium' | 'high' | 'critical';
  category: 'performance' | 'security' | 'reliability' | 'maintainability';
  description: string;
  impact: string;
  detectedAt: string;
  resolvedAt?: string;
}

interface QualityImprovement {
  id: string;
  type: 'fix' | 'enhancement' | 'optimization';
  description: string;
  implementedAt: string;
  impact: {
    before: number;
    after: number;
    improvement: number;
  };
}

export class QualityImprovementCycle {
  private static readonly QUALITY_HISTORY_FILE = 'quality-history.json';
  
  static async runWeeklyQualityReview(): Promise<void> {
    console.log('Starting weekly quality review...');
    
    // 1. ç¾åœ¨ã®å“è³ªãƒ¡ãƒˆãƒªã‚¯ã‚¹åé›†
    const currentMetrics = await QualityGateValidator.collectMetrics();
    
    // 2. å“è³ªãƒˆãƒ¬ãƒ³ãƒ‰åˆ†æ
    const trends = await this.analyzeQualityTrends();
    
    // 3. å•é¡Œã®ç‰¹å®š
    const issues = await this.identifyQualityIssues(currentMetrics, trends);
    
    // 4. æ”¹å–„ææ¡ˆã®ç”Ÿæˆ
    const improvements = await this.generateImprovementProposals(issues, trends);
    
    // 5. ãƒ¬ãƒãƒ¼ãƒˆç”Ÿæˆ
    const report = await this.generateQualityReport(currentMetrics, trends, issues, improvements);
    
    // 6. å±¥æ­´ã®æ›´æ–°
    await this.updateQualityHistory(currentMetrics, issues, improvements);
    
    console.log('Weekly quality review completed.');
    console.log(`Report saved to: ${report.filePath}`);
  }
  
  private static async analyzeQualityTrends(): Promise<QualityTrend[]> {
    try {
      const historyData = await Deno.readTextFile(this.QUALITY_HISTORY_FILE);
      return JSON.parse(historyData);
    } catch (error) {
      console.warn('No quality history found, starting fresh.');
      return [];
    }
  }
  
  private static async identifyQualityIssues(
    currentMetrics: QualityMetrics,
    trends: QualityTrend[]
  ): Promise<QualityIssue[]> {
    const issues: QualityIssue[] = [];
    
    // 1. é–¾å€¤é•åã®æ¤œå‡º
    if (currentMetrics.testCoverage < 90) {
      issues.push({
        id: `coverage-${Date.now()}`,
        severity: 'high',
        category: 'reliability',
        description: `Test coverage (${currentMetrics.testCoverage}%) below target (90%)`,
        impact: 'Increased risk of undetected bugs in production',
        detectedAt: new Date().toISOString()
      });
    }
    
    if (currentMetrics.responseTime > 200) {
      issues.push({
        id: `performance-${Date.now()}`,
        severity: 'medium',
        category: 'performance',
        description: `Average response time (${currentMetrics.responseTime}ms) exceeds target (200ms)`,
        impact: 'Degraded user experience and potential SLA violations',
        detectedAt: new Date().toISOString()
      });
    }
    
    if (currentMetrics.errorRate > 1) {
      issues.push({
        id: `errors-${Date.now()}`,
        severity: 'critical',
        category: 'reliability',
        description: `Error rate (${currentMetrics.errorRate}%) exceeds target (1%)`,
        impact: 'Service reliability concerns and user frustration',
        detectedAt: new Date().toISOString()
      });
    }
    
    // 2. ãƒˆãƒ¬ãƒ³ãƒ‰æ‚ªåŒ–ã®æ¤œå‡º
    if (trends.length >= 4) {
      const recentTrends = trends.slice(-4);
      
      // ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹æ‚ªåŒ–ãƒˆãƒ¬ãƒ³ãƒ‰
      const responseTimeTrend = this.calculateTrend(
        recentTrends.map(t => t.metrics.responseTime)
      );
      
      if (responseTimeTrend > 10) { // 10%ä»¥ä¸Šã®æ‚ªåŒ–
        issues.push({
          id: `trend-performance-${Date.now()}`,
          severity: 'medium',
          category: 'performance',
          description: `Response time showing upward trend (+${responseTimeTrend.toFixed(1)}%)`,
          impact: 'Gradual performance degradation may lead to SLA violations',
          detectedAt: new Date().toISOString()
        });
      }
      
      // ã‚¨ãƒ©ãƒ¼ç‡å¢—åŠ ãƒˆãƒ¬ãƒ³ãƒ‰
      const errorRateTrend = this.calculateTrend(
        recentTrends.map(t => t.metrics.errorRate)
      );
      
      if (errorRateTrend > 20) { // 20%ä»¥ä¸Šã®å¢—åŠ 
        issues.push({
          id: `trend-errors-${Date.now()}`,
          severity: 'high',
          category: 'reliability',
          description: `Error rate showing upward trend (+${errorRateTrend.toFixed(1)}%)`,
          impact: 'Increasing error rate indicates system instability',
          detectedAt: new Date().toISOString()
        });
      }
    }
    
    return issues;
  }
  
  private static calculateTrend(values: number[]): number {
    if (values.length < 2) return 0;
    
    const first = values[0];
    const last = values[values.length - 1];
    
    return ((last - first) / first) * 100;
  }
  
  private static async generateImprovementProposals(
    issues: QualityIssue[],
    trends: QualityTrend[]
  ): Promise<QualityImprovement[]> {
    const improvements: QualityImprovement[] = [];
    
    for (const issue of issues) {
      switch (issue.category) {
        case 'performance':
          improvements.push({
            id: `perf-improvement-${Date.now()}`,
            type: 'optimization',
            description: 'Implement response caching and database query optimization',
            implementedAt: '',
            impact: { before: 0, after: 0, improvement: 0 }
          });
          break;
          
        case 'reliability':
          if (issue.description.includes('coverage')) {
            improvements.push({
              id: `test-improvement-${Date.now()}`,
              type: 'enhancement',
              description: 'Add comprehensive test cases for uncovered code paths',
              implementedAt: '',
              impact: { before: 0, after: 0, improvement: 0 }
            });
          } else if (issue.description.includes('error')) {
            improvements.push({
              id: `error-improvement-${Date.now()}`,
              type: 'fix',
              description: 'Implement enhanced error handling and retry mechanisms',
              implementedAt: '',
              impact: { before: 0, after: 0, improvement: 0 }
            });
          }
          break;
          
        case 'security':
          improvements.push({
            id: `security-improvement-${Date.now()}`,
            type: 'enhancement',
            description: 'Strengthen security controls and vulnerability scanning',
            implementedAt: '',
            impact: { before: 0, after: 0, improvement: 0 }
          });
          break;
          
        case 'maintainability':
          improvements.push({
            id: `maintainability-improvement-${Date.now()}`,
            type: 'enhancement',
            description: 'Refactor complex code and improve documentation',
            implementedAt: '',
            impact: { before: 0, after: 0, improvement: 0 }
          });
          break;
      }
    }
    
    return improvements;
  }
  
  private static async generateQualityReport(
    currentMetrics: QualityMetrics,
    trends: QualityTrend[],
    issues: QualityIssue[],
    improvements: QualityImprovement[]
  ): Promise<{ filePath: string; content: string }> {
    const reportDate = new Date().toISOString().split('T')[0];
    const filePath = `quality-reports/quality-report-${reportDate}.md`;
    
    const content = `# RichmanManage API Quality Report
**Date**: ${new Date().toLocaleDateString()}
**Report Period**: Weekly Review

## Executive Summary

### Current Quality Status
- **Overall Score**: ${this.calculateOverallScore(currentMetrics)}/100
- **Test Coverage**: ${currentMetrics.testCoverage.toFixed(1)}%
- **Performance Score**: ${currentMetrics.performanceScore.toFixed(1)}/100
- **Security Score**: ${currentMetrics.securityScore.toFixed(1)}/100
- **Error Rate**: ${currentMetrics.errorRate.toFixed(2)}%
- **Avg Response Time**: ${currentMetrics.responseTime.toFixed(0)}ms

### Quality Trend Analysis
${this.generateTrendAnalysis(trends)}

## Issues Identified (${issues.length})

### Critical Issues (${issues.filter(i => i.severity === 'critical').length})
${issues.filter(i => i.severity === 'critical').map(issue => 
  `- **${issue.description}**\n  - Impact: ${issue.impact}\n  - Category: ${issue.category}`
).join('\n\n')}

### High Priority Issues (${issues.filter(i => i.severity === 'high').length})
${issues.filter(i => i.severity === 'high').map(issue => 
  `- **${issue.description}**\n  - Impact: ${issue.impact}\n  - Category: ${issue.category}`
).join('\n\n')}

### Medium Priority Issues (${issues.filter(i => i.severity === 'medium').length})
${issues.filter(i => i.severity === 'medium').map(issue => 
  `- **${issue.description}**\n  - Impact: ${issue.impact}\n  - Category: ${issue.category}`
).join('\n\n')}

## Improvement Recommendations (${improvements.length})

${improvements.map((improvement, index) => 
  `### ${index + 1}. ${improvement.description}
- **Type**: ${improvement.type}
- **Priority**: ${this.getImprovementPriority(improvement)}
- **Estimated Impact**: ${this.getEstimatedImpact(improvement)}`
).join('\n\n')}

## Action Items

### Immediate Actions (Next 24 hours)
${issues.filter(i => i.severity === 'critical').map(issue => 
  `- [ ] Address: ${issue.description}`
).join('\n')}

### Short-term Actions (Next Week)
${issues.filter(i => i.severity === 'high').map(issue => 
  `- [ ] Resolve: ${issue.description}`
).join('\n')}

### Medium-term Actions (Next Month)
${improvements.slice(0, 3).map(improvement => 
  `- [ ] Implement: ${improvement.description}`
).join('\n')}

## Quality Metrics History

| Date | Coverage | Performance | Security | Error Rate | Response Time |
|------|----------|-------------|----------|------------|---------------|
${trends.slice(-5).map(trend => 
  `| ${trend.date} | ${trend.metrics.testCoverage.toFixed(1)}% | ${trend.metrics.performanceScore.toFixed(1)} | ${trend.metrics.securityScore.toFixed(1)} | ${trend.metrics.errorRate.toFixed(2)}% | ${trend.metrics.responseTime.toFixed(0)}ms |`
).join('\n')}
| **Current** | **${currentMetrics.testCoverage.toFixed(1)}%** | **${currentMetrics.performanceScore.toFixed(1)}** | **${currentMetrics.securityScore.toFixed(1)}** | **${currentMetrics.errorRate.toFixed(2)}%** | **${currentMetrics.responseTime.toFixed(0)}ms** |

---
*Generated by RichmanManage Quality Improvement System*
`;

    // ãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒªã®ä½œæˆ
    await Deno.mkdir('quality-reports', { recursive: true });
    
    // ãƒ¬ãƒãƒ¼ãƒˆãƒ•ã‚¡ã‚¤ãƒ«ã®ä¿å­˜
    await Deno.writeTextFile(filePath, content);
    
    return { filePath, content };
  }
  
  private static calculateOverallScore(metrics: QualityMetrics): number {
    const weights = {
      testCoverage: 0.25,
      performanceScore: 0.25,
      securityScore: 0.25,
      codeQualityScore: 0.15,
      errorRate: 0.05, // é€†ã‚¹ã‚³ã‚¢ï¼ˆä½ã„ã»ã©è‰¯ã„ï¼‰
      responseTime: 0.05 // é€†ã‚¹ã‚³ã‚¢ï¼ˆä½ã„ã»ã©è‰¯ã„ï¼‰
    };
    
    const errorRateScore = Math.max(0, 100 - (metrics.errorRate * 10));
    const responseTimeScore = Math.max(0, 100 - (metrics.responseTime / 5));
    
    return Math.round(
      metrics.testCoverage * weights.testCoverage +
      metrics.performanceScore * weights.performanceScore +
      metrics.securityScore * weights.securityScore +
      metrics.codeQualityScore * weights.codeQualityScore +
      errorRateScore * weights.errorRate +
      responseTimeScore * weights.responseTime
    );
  }
  
  private static generateTrendAnalysis(trends: QualityTrend[]): string {
    if (trends.length < 2) {
      return 'Insufficient data for trend analysis.';
    }
    
    const latest = trends[trends.length - 1];
    const previous = trends[trends.length - 2];
    
    const coverageTrend = latest.metrics.testCoverage - previous.metrics.testCoverage;
    const performanceTrend = latest.metrics.performanceScore - previous.metrics.performanceScore;
    const securityTrend = latest.metrics.securityScore - previous.metrics.securityScore;
    
    return `
- **Test Coverage**: ${coverageTrend >= 0 ? 'ğŸ“ˆ' : 'ğŸ“‰'} ${coverageTrend >= 0 ? '+' : ''}${coverageTrend.toFixed(1)}%
- **Performance**: ${performanceTrend >= 0 ? 'ğŸ“ˆ' : 'ğŸ“‰'} ${performanceTrend >= 0 ? '+' : ''}${performanceTrend.toFixed(1)} points
- **Security**: ${securityTrend >= 0 ? 'ğŸ“ˆ' : 'ğŸ“‰'} ${securityTrend >= 0 ? '+' : ''}${securityTrend.toFixed(1)} points
`;
  }
  
  private static getImprovementPriority(improvement: QualityImprovement): string {
    switch (improvement.type) {
      case 'fix': return 'High';
      case 'optimization': return 'Medium';
      case 'enhancement': return 'Low';
      default: return 'Medium';
    }
  }
  
  private static getEstimatedImpact(improvement: QualityImprovement): string {
    switch (improvement.type) {
      case 'fix': return 'High - Immediate quality improvement';
      case 'optimization': return 'Medium - Performance enhancement';
      case 'enhancement': return 'Low - Long-term quality benefits';
      default: return 'Medium - General improvement';
    }
  }
  
  private static async updateQualityHistory(
    currentMetrics: QualityMetrics,
    issues: QualityIssue[],
    improvements: QualityImprovement[]
  ): Promise<void> {
    const trends = await this.analyzeQualityTrends();
    
    const newTrend: QualityTrend = {
      date: new Date().toISOString().split('T')[0],
      metrics: currentMetrics,
      issues,
      improvements
    };
    
    trends.push(newTrend);
    
    // å±¥æ­´ã‚’æœ€æ–°ã®52é€±é–“ï¼ˆ1å¹´ï¼‰ã«åˆ¶é™
    const limitedTrends = trends.slice(-52);
    
    await Deno.writeTextFile(
      this.QUALITY_HISTORY_FILE,
      JSON.stringify(limitedTrends, null, 2)
    );
  }
}

// å®šæœŸå®Ÿè¡Œã‚¹ã‚±ã‚¸ãƒ¥ãƒ¼ãƒ«
if (import.meta.main) {
  await QualityImprovementCycle.runWeeklyQualityReview();
}
```

---

## ğŸ¯ çµè«–

æœ¬å“è³ªä¿è¨¼ãƒ»ãƒ™ã‚¹ãƒˆãƒ—ãƒ©ã‚¯ãƒ†ã‚£ã‚¹å®Ÿè£…ã‚¬ã‚¤ãƒ‰ã«ã‚ˆã‚Šã€RichmanManage APIã¯ä¸–ç•Œã‚¯ãƒ©ã‚¹å“è³ªã®åŸºæº–ã‚’æº€ãŸã™ã‚·ã‚¹ãƒ†ãƒ ã¨ã—ã¦æ§‹ç¯‰ã•ã‚Œã¾ã™ã€‚åŒ…æ‹¬çš„ãªãƒ†ã‚¹ãƒˆæˆ¦ç•¥ã€ç¶™ç¶šçš„ç›£è¦–ã€è‡ªå‹•åŒ–ã•ã‚ŒãŸCI/CDã€å“è³ªæ”¹å–„ã‚µã‚¤ã‚¯ãƒ«ã®çµ„ã¿åˆã‚ã›ã«ã‚ˆã‚Šã€é•·æœŸçš„ãªæˆåŠŸã¨ä¿¡é ¼æ€§ã‚’ç¢ºä¿ã—ã¾ã™ã€‚

### ğŸ† æœŸå¾…ã•ã‚Œã‚‹æˆæœ

**æŠ€è¡“çš„æˆæœ**:
- APIå¿œç­”æ™‚é–“ < 200ms (95%ile)
- å¯ç”¨æ€§ > 99.9%
- ãƒ†ã‚¹ãƒˆã‚«ãƒãƒ¬ãƒƒã‚¸ > 90%
- ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£è„†å¼±æ€§ 0ä»¶

**ãƒ“ã‚¸ãƒã‚¹æˆæœ**:
- ãƒ¦ãƒ¼ã‚¶ãƒ¼æº€è¶³åº¦ > 95%
- é–‹ç™ºåŠ¹ç‡ 40%å‘ä¸Š
- ä¿å®ˆã‚³ã‚¹ãƒˆ 50%å‰Šæ¸›
- å¸‚å ´æŠ•å…¥æ™‚é–“ 30%çŸ­ç¸®

**ç«¶åˆå„ªä½æ€§**:
- ã‚¨ãƒ³ã‚¿ãƒ¼ãƒ—ãƒ©ã‚¤ã‚ºã‚°ãƒ¬ãƒ¼ãƒ‰å“è³ª
- å›½éš›æ¨™æº–æº–æ‹ 
- ç¶™ç¶šçš„å“è³ªæ”¹å–„
- ä¸–ç•Œã‚¯ãƒ©ã‚¹ã®ä¿¡é ¼æ€§

ã“ã®å“è³ªä¿è¨¼ãƒ•ãƒ¬ãƒ¼ãƒ ãƒ¯ãƒ¼ã‚¯ã«ã‚ˆã‚Šã€RichmanManageã¯ä¸å‹•ç”£æŠ•è³‡ç®¡ç†åˆ†é‡ã®ãƒªãƒ¼ãƒ‡ã‚£ãƒ³ã‚°ãƒ—ãƒ­ãƒ€ã‚¯ãƒˆã¨ã—ã¦ã®åœ°ä½ã‚’ç¢ºç«‹ã—ã€ãƒ¦ãƒ¼ã‚¶ãƒ¼ã®è²´é‡ãªãƒ‡ãƒ¼ã‚¿ã‚’æœ€é«˜æ°´æº–ã§ä¿è­·ãƒ»ç®¡ç†ã™ã‚‹ã“ã¨ãŒã§ãã¾ã™ã€‚

