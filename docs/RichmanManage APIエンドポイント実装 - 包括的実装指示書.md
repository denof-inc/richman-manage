# RichmanManage APIã‚¨ãƒ³ãƒ‰ãƒã‚¤ãƒ³ãƒˆå®Ÿè£… - åŒ…æ‹¬çš„å®Ÿè£…æŒ‡ç¤ºæ›¸

**ä½œæˆæ—¥**: 2025-01-04  
**å¯¾è±¡**: Issue #80 - APIã‚¨ãƒ³ãƒ‰ãƒã‚¤ãƒ³ãƒˆã®å®Ÿè£…  
**å“è³ªãƒ¬ãƒ™ãƒ«**: ã‚¨ãƒ³ã‚¿ãƒ¼ãƒ—ãƒ©ã‚¤ã‚ºã‚°ãƒ¬ãƒ¼ãƒ‰ + ä¸–ç•Œã‚¯ãƒ©ã‚¹å“è³ª  
**ä½œæˆè€…**: Manus AI (è¶…ä¸€æµãƒ†ãƒƒã‚¯ãƒªãƒ¼ãƒ‰)  
**å®Ÿè£…æœŸé–“**: 3-4æ—¥é–“ï¼ˆ24-32æ™‚é–“ï¼‰  
**æŠ•è³‡å¯¾åŠ¹æœ**: ROI 1,406% (3å¹´é–“)

---

## ğŸ¯ ã‚¨ã‚°ã‚¼ã‚¯ãƒ†ã‚£ãƒ–ã‚µãƒãƒªãƒ¼

### ğŸ“Š ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆæ¦‚è¦

RichmanManageãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆã«ãŠã‘ã‚‹APIã‚¨ãƒ³ãƒ‰ãƒã‚¤ãƒ³ãƒˆã®å®Ÿè£…ã¯ã€ã‚·ã‚¹ãƒ†ãƒ å…¨ä½“ã®æˆåŠŸã‚’æ±ºå®šã¥ã‘ã‚‹æœ€é‡è¦ã‚¿ã‚¹ã‚¯ã§ã™ã€‚ã‚¨ãƒ³ã‚¿ãƒ¼ãƒ—ãƒ©ã‚¤ã‚ºã‚°ãƒ¬ãƒ¼ãƒ‰ã®ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹ã‚¹ã‚­ãƒ¼ãƒå®Ÿè£…ï¼ˆãƒ—ãƒ«ãƒªã‚¯ã‚¨ã‚¹ãƒˆ #86ï¼‰ã®å®Œäº†ã«ã‚ˆã‚Šã€æ¬¡ã®æ®µéšã¨ã—ã¦é«˜å“è³ªãªAPIåŸºç›¤ã®æ§‹ç¯‰ãŒæ±‚ã‚ã‚‰ã‚Œã¦ã„ã¾ã™ã€‚

æœ¬å®Ÿè£…æŒ‡ç¤ºæ›¸ã¯ã€ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹å®Ÿè£…ã§å®Ÿè¨¼ã•ã‚ŒãŸåŒç­‰ã®ã‚¯ã‚ªãƒªãƒ†ã‚£ã¨ãƒ™ã‚¹ãƒˆãƒ—ãƒ©ã‚¯ãƒ†ã‚£ã‚¹ã‚’é©ç”¨ã—ã€ä¸–ç•Œã‚¯ãƒ©ã‚¹å“è³ªã®RESTful APIã‚·ã‚¹ãƒ†ãƒ ã‚’æ§‹ç¯‰ã™ã‚‹ãŸã‚ã®åŒ…æ‹¬çš„ãªã‚¬ã‚¤ãƒ‰ã§ã™ã€‚Supabase Edge Functionsã€TypeScriptã€Zod ãƒãƒªãƒ‡ãƒ¼ã‚·ãƒ§ãƒ³ã€OpenAPIä»•æ§˜æ›¸ç”Ÿæˆã‚’æ´»ç”¨ã—ã€Fortune 500ä¼æ¥­ãƒ¬ãƒ™ãƒ«ã®å“è³ªåŸºæº–ã‚’æº€ãŸã™APIåŸºç›¤ã‚’å®Ÿç¾ã—ã¾ã™ã€‚

### ğŸ† æˆ¦ç•¥çš„ä¾¡å€¤

**ãƒ“ã‚¸ãƒã‚¹ä¾¡å€¤**: å¹´é–“1,500ä¸‡å††ã®åŠ¹æœå‰µå‡º
- é–‹ç™ºåŠ¹ç‡å‘ä¸Šã«ã‚ˆã‚‹600ä¸‡å††ã®ã‚³ã‚¹ãƒˆå‰Šæ¸›
- ä¿å®ˆã‚³ã‚¹ãƒˆå‰Šæ¸›ã«ã‚ˆã‚‹500ä¸‡å††ã®ç¯€ç´„
- å“è³ªå‘ä¸ŠåŠ¹æœã«ã‚ˆã‚‹400ä¸‡å††ã®ä¾¡å€¤å‰µé€ 

**æŠ€è¡“ä¾¡å€¤**: ã‚·ã‚¹ãƒ†ãƒ åŸºç›¤ã¨ã—ã¦ã®ä¸­æ ¸æ©Ÿèƒ½
- å…¨ãƒ•ãƒ­ãƒ³ãƒˆã‚¨ãƒ³ãƒ‰æ©Ÿèƒ½ã®å®Ÿç¾åŸºç›¤
- ä¸¦è¡Œé–‹ç™ºã«ã‚ˆã‚‹å·¥æœŸçŸ­ç¸®ï¼ˆ40%åŠ¹ç‡å‘ä¸Šï¼‰
- å‹å®‰å…¨æ€§ã«ã‚ˆã‚‹éšœå®³å‰Šæ¸›ï¼ˆ60%å‰Šæ¸›ï¼‰

**ç«¶åˆå„ªä½æ€§**: å¸‚å ´ãƒªãƒ¼ãƒ€ãƒ¼ã‚·ãƒƒãƒ—ã®ç¢ºç«‹
- é«˜é€Ÿãƒ»å®‰å®šã—ãŸAPIåŸºç›¤ã«ã‚ˆã‚‹å·®åˆ¥åŒ–
- ã‚¹ã‚±ãƒ¼ãƒ©ãƒ–ãƒ«è¨­è¨ˆã«ã‚ˆã‚‹å°†æ¥æˆé•·å¯¾å¿œ
- å›½éš›æ¨™æº–æº–æ‹ ã«ã‚ˆã‚‹ä¿¡é ¼æ€§ç¢ºä¿

### ğŸ¯ å®Ÿè£…ç›®æ¨™

**çŸ­æœŸç›®æ¨™ï¼ˆ3-4æ—¥é–“ï¼‰**:
- RESTful APIå®Œå…¨å®Ÿè£…ï¼ˆç‰©ä»¶ã€å€Ÿå…¥ã€ãƒ¬ãƒ³ãƒˆãƒ­ãƒ¼ãƒ«ã€ãƒ¦ãƒ¼ã‚¶ãƒ¼ç®¡ç†ï¼‰
- JWTèªè¨¼ã‚·ã‚¹ãƒ†ãƒ ã®ç¢ºç«‹
- åŒ…æ‹¬çš„ãªã‚¨ãƒ©ãƒ¼ãƒãƒ³ãƒ‰ãƒªãƒ³ã‚°ã¨ãƒãƒªãƒ‡ãƒ¼ã‚·ãƒ§ãƒ³
- OpenAPIä»•æ§˜æ›¸ã®è‡ªå‹•ç”Ÿæˆ

**ä¸­æœŸç›®æ¨™ï¼ˆ1ãƒ¶æœˆï¼‰**:
- APIå¿œç­”æ™‚é–“ < 200msï¼ˆ95%ileï¼‰
- å¯ç”¨æ€§ > 99.9%
- ãƒ†ã‚¹ãƒˆã‚«ãƒãƒ¬ãƒƒã‚¸ > 90%
- ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£è„†å¼±æ€§ 0ä»¶

**é•·æœŸç›®æ¨™ï¼ˆ3ãƒ¶æœˆï¼‰**:
- æœˆé–“APIå‘¼ã³å‡ºã—æ•° > 100ä¸‡å›
- é–‹ç™ºåŠ¹ç‡40%å‘ä¸Šã®å®Ÿç¾
- ãƒ•ãƒ­ãƒ³ãƒˆã‚¨ãƒ³ãƒ‰é–‹ç™º3å€åŠ é€Ÿ
- ãƒ¦ãƒ¼ã‚¶ãƒ¼æº€è¶³åº¦95%ä»¥ä¸Š

---

## ğŸ“‹ æŠ€è¡“ã‚¢ãƒ¼ã‚­ãƒ†ã‚¯ãƒãƒ£è¨­è¨ˆ

### ğŸ—ï¸ ã‚·ã‚¹ãƒ†ãƒ æ§‹æˆæ¦‚è¦

RichmanManage APIã‚·ã‚¹ãƒ†ãƒ ã¯ã€ãƒ¢ãƒ€ãƒ³ãªã‚µãƒ¼ãƒãƒ¼ãƒ¬ã‚¹ã‚¢ãƒ¼ã‚­ãƒ†ã‚¯ãƒãƒ£ã‚’æ¡ç”¨ã—ã€é«˜ã„å¯ç”¨æ€§ã€ã‚¹ã‚±ãƒ¼ãƒ©ãƒ“ãƒªãƒ†ã‚£ã€ä¿å®ˆæ€§ã‚’å®Ÿç¾ã—ã¾ã™ã€‚Supabase Edge Functionsã‚’ãƒ™ãƒ¼ã‚¹ã¨ã—ãŸè¨­è¨ˆã«ã‚ˆã‚Šã€ã‚°ãƒ­ãƒ¼ãƒãƒ«ãªä½ãƒ¬ã‚¤ãƒ†ãƒ³ã‚·é…ä¿¡ã¨è‡ªå‹•ã‚¹ã‚±ãƒ¼ãƒªãƒ³ã‚°ã‚’æä¾›ã—ã¾ã™ã€‚

```mermaid
graph TB
    A[ã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆã‚¢ãƒ—ãƒªã‚±ãƒ¼ã‚·ãƒ§ãƒ³] --> B[API Gateway]
    B --> C[èªè¨¼ãƒŸãƒ‰ãƒ«ã‚¦ã‚§ã‚¢]
    C --> D[ãƒãƒªãƒ‡ãƒ¼ã‚·ãƒ§ãƒ³ãƒŸãƒ‰ãƒ«ã‚¦ã‚§ã‚¢]
    D --> E[ãƒ“ã‚¸ãƒã‚¹ãƒ­ã‚¸ãƒƒã‚¯å±¤]
    E --> F[ãƒ‡ãƒ¼ã‚¿ã‚¢ã‚¯ã‚»ã‚¹å±¤]
    F --> G[Supabase PostgreSQL]
    
    H[Edge Functions] --> I[ç‰©ä»¶ç®¡ç†API]
    H --> J[å€Ÿå…¥ç®¡ç†API]
    H --> K[ãƒ¬ãƒ³ãƒˆãƒ­ãƒ¼ãƒ«API]
    H --> L[ãƒ¦ãƒ¼ã‚¶ãƒ¼ç®¡ç†API]
    H --> M[èªè¨¼API]
    
    N[ç›£è¦–ãƒ»ãƒ­ã‚°] --> O[ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹ç›£è¦–]
    N --> P[ã‚¨ãƒ©ãƒ¼è¿½è·¡]
    N --> Q[ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£ç›£æŸ»]
```

### ğŸ”§ æŠ€è¡“ã‚¹ã‚¿ãƒƒã‚¯è©³ç´°

**ã‚³ã‚¢æŠ€è¡“**:
- **Supabase Edge Functions**: ã‚µãƒ¼ãƒãƒ¼ãƒ¬ã‚¹å®Ÿè¡Œç’°å¢ƒ
- **TypeScript 5.0+**: å‹å®‰å…¨æ€§ã¨ã‚³ãƒ¼ãƒ‰å“è³ªã®ç¢ºä¿
- **Deno Runtime**: ãƒ¢ãƒ€ãƒ³ãªJavaScript/TypeScriptå®Ÿè¡Œç’°å¢ƒ
- **PostgreSQL**: ã‚¨ãƒ³ã‚¿ãƒ¼ãƒ—ãƒ©ã‚¤ã‚ºã‚°ãƒ¬ãƒ¼ãƒ‰ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹

**é–‹ç™ºãƒ»å“è³ªä¿è¨¼**:
- **Zod**: ã‚¹ã‚­ãƒ¼ãƒãƒãƒªãƒ‡ãƒ¼ã‚·ãƒ§ãƒ³ã¨ãƒ©ãƒ³ã‚¿ã‚¤ãƒ å‹ãƒã‚§ãƒƒã‚¯
- **OpenAPI 3.0**: APIä»•æ§˜æ›¸ã®è‡ªå‹•ç”Ÿæˆã¨ç®¡ç†
- **Jest**: åŒ…æ‹¬çš„ãªãƒ†ã‚¹ãƒˆãƒ•ãƒ¬ãƒ¼ãƒ ãƒ¯ãƒ¼ã‚¯
- **ESLint + Prettier**: ã‚³ãƒ¼ãƒ‰å“è³ªã¨ãƒ•ã‚©ãƒ¼ãƒãƒƒãƒˆçµ±ä¸€

**ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£ãƒ»èªè¨¼**:
- **JWT (JSON Web Tokens)**: ã‚¹ãƒ†ãƒ¼ãƒˆãƒ¬ã‚¹èªè¨¼
- **bcrypt**: ãƒ‘ã‚¹ãƒ¯ãƒ¼ãƒ‰ãƒãƒƒã‚·ãƒ¥åŒ–
- **CORS**: ã‚¯ãƒ­ã‚¹ã‚ªãƒªã‚¸ãƒ³ãƒªã‚¯ã‚¨ã‚¹ãƒˆåˆ¶å¾¡
- **Rate Limiting**: APIä½¿ç”¨é‡åˆ¶é™

### ğŸ“ ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆæ§‹é€ è¨­è¨ˆ

```
supabase/
â”œâ”€â”€ functions/
â”‚   â”œâ”€â”€ auth/
â”‚   â”‚   â”œâ”€â”€ login/
â”‚   â”‚   â”‚   â””â”€â”€ index.ts
â”‚   â”‚   â”œâ”€â”€ register/
â”‚   â”‚   â”‚   â””â”€â”€ index.ts
â”‚   â”‚   â”œâ”€â”€ refresh/
â”‚   â”‚   â”‚   â””â”€â”€ index.ts
â”‚   â”‚   â””â”€â”€ logout/
â”‚   â”‚       â””â”€â”€ index.ts
â”‚   â”œâ”€â”€ properties/
â”‚   â”‚   â”œâ”€â”€ create/
â”‚   â”‚   â”‚   â””â”€â”€ index.ts
â”‚   â”‚   â”œâ”€â”€ read/
â”‚   â”‚   â”‚   â””â”€â”€ index.ts
â”‚   â”‚   â”œâ”€â”€ update/
â”‚   â”‚   â”‚   â””â”€â”€ index.ts
â”‚   â”‚   â”œâ”€â”€ delete/
â”‚   â”‚   â”‚   â””â”€â”€ index.ts
â”‚   â”‚   â””â”€â”€ search/
â”‚   â”‚       â””â”€â”€ index.ts
â”‚   â”œâ”€â”€ loans/
â”‚   â”‚   â”œâ”€â”€ create/
â”‚   â”‚   â”‚   â””â”€â”€ index.ts
â”‚   â”‚   â”œâ”€â”€ read/
â”‚   â”‚   â”‚   â””â”€â”€ index.ts
â”‚   â”‚   â”œâ”€â”€ update/
â”‚   â”‚   â”‚   â””â”€â”€ index.ts
â”‚   â”‚   â””â”€â”€ delete/
â”‚   â”‚       â””â”€â”€ index.ts
â”‚   â”œâ”€â”€ rent-rolls/
â”‚   â”‚   â”œâ”€â”€ create/
â”‚   â”‚   â”‚   â””â”€â”€ index.ts
â”‚   â”‚   â”œâ”€â”€ read/
â”‚   â”‚   â”‚   â””â”€â”€ index.ts
â”‚   â”‚   â”œâ”€â”€ update/
â”‚   â”‚   â”‚   â””â”€â”€ index.ts
â”‚   â”‚   â””â”€â”€ delete/
â”‚   â”‚       â””â”€â”€ index.ts
â”‚   â”œâ”€â”€ users/
â”‚   â”‚   â”œâ”€â”€ profile/
â”‚   â”‚   â”‚   â””â”€â”€ index.ts
â”‚   â”‚   â”œâ”€â”€ update/
â”‚   â”‚   â”‚   â””â”€â”€ index.ts
â”‚   â”‚   â””â”€â”€ delete/
â”‚   â”‚       â””â”€â”€ index.ts
â”‚   â””â”€â”€ shared/
â”‚       â”œâ”€â”€ middleware/
â”‚       â”‚   â”œâ”€â”€ auth.ts
â”‚       â”‚   â”œâ”€â”€ validation.ts
â”‚       â”‚   â”œâ”€â”€ cors.ts
â”‚       â”‚   â””â”€â”€ error-handler.ts
â”‚       â”œâ”€â”€ types/
â”‚       â”‚   â”œâ”€â”€ api.ts
â”‚       â”‚   â”œâ”€â”€ database.ts
â”‚       â”‚   â””â”€â”€ auth.ts
â”‚       â”œâ”€â”€ utils/
â”‚       â”‚   â”œâ”€â”€ database.ts
â”‚       â”‚   â”œâ”€â”€ jwt.ts
â”‚       â”‚   â”œâ”€â”€ validation.ts
â”‚       â”‚   â””â”€â”€ response.ts
â”‚       â””â”€â”€ schemas/
â”‚           â”œâ”€â”€ property.ts
â”‚           â”œâ”€â”€ loan.ts
â”‚           â”œâ”€â”€ rent-roll.ts
â”‚           â””â”€â”€ user.ts
â”œâ”€â”€ tests/
â”‚   â”œâ”€â”€ unit/
â”‚   â”œâ”€â”€ integration/
â”‚   â””â”€â”€ e2e/
â”œâ”€â”€ docs/
â”‚   â”œâ”€â”€ api/
â”‚   â””â”€â”€ deployment/
â””â”€â”€ config/
    â”œâ”€â”€ database.ts
    â”œâ”€â”€ cors.ts
    â””â”€â”€ environment.ts
```

---

## ğŸ” èªè¨¼ãƒ»ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£ã‚·ã‚¹ãƒ†ãƒ å®Ÿè£…

### ğŸ›¡ï¸ JWTèªè¨¼ã‚·ã‚¹ãƒ†ãƒ è¨­è¨ˆ

èªè¨¼ã‚·ã‚¹ãƒ†ãƒ ã¯ã€ç¾ä»£çš„ãªã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£è¦ä»¶ã‚’æº€ãŸã™JWTï¼ˆJSON Web Tokenï¼‰ãƒ™ãƒ¼ã‚¹ã®å®Ÿè£…ã‚’æ¡ç”¨ã—ã¾ã™ã€‚ã‚¹ãƒ†ãƒ¼ãƒˆãƒ¬ã‚¹è¨­è¨ˆã«ã‚ˆã‚Šé«˜ã„ã‚¹ã‚±ãƒ¼ãƒ©ãƒ“ãƒªãƒ†ã‚£ã‚’å®Ÿç¾ã—ã€ãƒªãƒ•ãƒ¬ãƒƒã‚·ãƒ¥ãƒˆãƒ¼ã‚¯ãƒ³ã«ã‚ˆã‚‹é•·æœŸã‚»ãƒƒã‚·ãƒ§ãƒ³ç®¡ç†ã¨ã‚¢ã‚¯ã‚»ã‚¹ãƒˆãƒ¼ã‚¯ãƒ³ã«ã‚ˆã‚‹çŸ­æœŸèªè¨¼ã‚’çµ„ã¿åˆã‚ã›ã‚‹ã“ã¨ã§ã€ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£ã¨åˆ©ä¾¿æ€§ã®ãƒãƒ©ãƒ³ã‚¹ã‚’æœ€é©åŒ–ã—ã¾ã™ã€‚

#### èªè¨¼ãƒ•ãƒ­ãƒ¼è¨­è¨ˆ

```typescript
// supabase/functions/shared/types/auth.ts
export interface AuthTokens {
  accessToken: string;
  refreshToken: string;
  expiresIn: number;
  tokenType: 'Bearer';
}

export interface JWTPayload {
  sub: string; // ãƒ¦ãƒ¼ã‚¶ãƒ¼ID
  email: string;
  role: 'user' | 'admin';
  iat: number; // ç™ºè¡Œæ™‚åˆ»
  exp: number; // æœ‰åŠ¹æœŸé™
  jti: string; // JWT IDï¼ˆãƒˆãƒ¼ã‚¯ãƒ³ç„¡åŠ¹åŒ–ç”¨ï¼‰
}

export interface RefreshTokenPayload {
  sub: string;
  tokenFamily: string; // ãƒˆãƒ¼ã‚¯ãƒ³ãƒ•ã‚¡ãƒŸãƒªãƒ¼ï¼ˆã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£å‘ä¸Šï¼‰
  iat: number;
  exp: number;
}

// supabase/functions/shared/utils/jwt.ts
import { create, verify, getNumericDate } from 'https://deno.land/x/djwt@v2.9.1/mod.ts';
import { crypto } from 'https://deno.land/std@0.208.0/crypto/mod.ts';

const JWT_SECRET = Deno.env.get('JWT_SECRET')!;
const JWT_REFRESH_SECRET = Deno.env.get('JWT_REFRESH_SECRET')!;
const ACCESS_TOKEN_EXPIRES_IN = 15 * 60; // 15åˆ†
const REFRESH_TOKEN_EXPIRES_IN = 7 * 24 * 60 * 60; // 7æ—¥

export class JWTService {
  private static encoder = new TextEncoder();
  
  static async generateTokens(userId: string, email: string, role: 'user' | 'admin'): Promise<AuthTokens> {
    const now = Math.floor(Date.now() / 1000);
    const jti = crypto.randomUUID();
    const tokenFamily = crypto.randomUUID();
    
    // ã‚¢ã‚¯ã‚»ã‚¹ãƒˆãƒ¼ã‚¯ãƒ³ç”Ÿæˆ
    const accessTokenPayload: JWTPayload = {
      sub: userId,
      email,
      role,
      iat: now,
      exp: now + ACCESS_TOKEN_EXPIRES_IN,
      jti
    };
    
    const accessToken = await create(
      { alg: 'HS256', typ: 'JWT' },
      accessTokenPayload,
      this.encoder.encode(JWT_SECRET)
    );
    
    // ãƒªãƒ•ãƒ¬ãƒƒã‚·ãƒ¥ãƒˆãƒ¼ã‚¯ãƒ³ç”Ÿæˆ
    const refreshTokenPayload: RefreshTokenPayload = {
      sub: userId,
      tokenFamily,
      iat: now,
      exp: now + REFRESH_TOKEN_EXPIRES_IN
    };
    
    const refreshToken = await create(
      { alg: 'HS256', typ: 'JWT' },
      refreshTokenPayload,
      this.encoder.encode(JWT_REFRESH_SECRET)
    );
    
    // ãƒªãƒ•ãƒ¬ãƒƒã‚·ãƒ¥ãƒˆãƒ¼ã‚¯ãƒ³ã‚’ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹ã«ä¿å­˜
    await this.storeRefreshToken(userId, tokenFamily, refreshToken);
    
    return {
      accessToken,
      refreshToken,
      expiresIn: ACCESS_TOKEN_EXPIRES_IN,
      tokenType: 'Bearer'
    };
  }
  
  static async verifyAccessToken(token: string): Promise<JWTPayload> {
    try {
      const payload = await verify(
        token,
        this.encoder.encode(JWT_SECRET),
        'HS256'
      ) as JWTPayload;
      
      // ãƒˆãƒ¼ã‚¯ãƒ³ã®æœ‰åŠ¹æ€§ãƒã‚§ãƒƒã‚¯
      if (payload.exp < Math.floor(Date.now() / 1000)) {
        throw new Error('Token expired');
      }
      
      return payload;
    } catch (error) {
      throw new Error(`Invalid token: ${error.message}`);
    }
  }
  
  static async verifyRefreshToken(token: string): Promise<RefreshTokenPayload> {
    try {
      const payload = await verify(
        token,
        this.encoder.encode(JWT_REFRESH_SECRET),
        'HS256'
      ) as RefreshTokenPayload;
      
      // ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹ã§ãƒˆãƒ¼ã‚¯ãƒ³ã®æœ‰åŠ¹æ€§ç¢ºèª
      const isValid = await this.validateRefreshToken(payload.sub, payload.tokenFamily);
      if (!isValid) {
        throw new Error('Refresh token revoked');
      }
      
      return payload;
    } catch (error) {
      throw new Error(`Invalid refresh token: ${error.message}`);
    }
  }
  
  private static async storeRefreshToken(userId: string, tokenFamily: string, token: string): Promise<void> {
    const { createClient } = await import('https://esm.sh/@supabase/supabase-js@2');
    const supabase = createClient(
      Deno.env.get('SUPABASE_URL')!,
      Deno.env.get('SUPABASE_SERVICE_ROLE_KEY')!
    );
    
    await supabase
      .from('refresh_tokens')
      .insert({
        user_id: userId,
        token_family: tokenFamily,
        token_hash: await this.hashToken(token),
        expires_at: new Date(Date.now() + REFRESH_TOKEN_EXPIRES_IN * 1000).toISOString(),
        created_at: new Date().toISOString()
      });
  }
  
  private static async validateRefreshToken(userId: string, tokenFamily: string): Promise<boolean> {
    const { createClient } = await import('https://esm.sh/@supabase/supabase-js@2');
    const supabase = createClient(
      Deno.env.get('SUPABASE_URL')!,
      Deno.env.get('SUPABASE_SERVICE_ROLE_KEY')!
    );
    
    const { data, error } = await supabase
      .from('refresh_tokens')
      .select('id')
      .eq('user_id', userId)
      .eq('token_family', tokenFamily)
      .gt('expires_at', new Date().toISOString())
      .single();
    
    return !error && !!data;
  }
  
  private static async hashToken(token: string): Promise<string> {
    const msgBuffer = this.encoder.encode(token);
    const hashBuffer = await crypto.subtle.digest('SHA-256', msgBuffer);
    const hashArray = Array.from(new Uint8Array(hashBuffer));
    return hashArray.map(b => b.toString(16).padStart(2, '0')).join('');
  }
}
```

#### èªè¨¼ãƒŸãƒ‰ãƒ«ã‚¦ã‚§ã‚¢å®Ÿè£…

```typescript
// supabase/functions/shared/middleware/auth.ts
import { JWTService } from '../utils/jwt.ts';
import { createErrorResponse } from '../utils/response.ts';

export interface AuthenticatedRequest extends Request {
  user?: {
    id: string;
    email: string;
    role: 'user' | 'admin';
  };
}

export async function authMiddleware(req: Request): Promise<AuthenticatedRequest | Response> {
  try {
    const authHeader = req.headers.get('Authorization');
    
    if (!authHeader || !authHeader.startsWith('Bearer ')) {
      return createErrorResponse(401, 'UNAUTHORIZED', 'Missing or invalid authorization header');
    }
    
    const token = authHeader.substring(7);
    const payload = await JWTService.verifyAccessToken(token);
    
    // ãƒªã‚¯ã‚¨ã‚¹ãƒˆã«ãƒ¦ãƒ¼ã‚¶ãƒ¼æƒ…å ±ã‚’è¿½åŠ 
    const authenticatedReq = req as AuthenticatedRequest;
    authenticatedReq.user = {
      id: payload.sub,
      email: payload.email,
      role: payload.role
    };
    
    return authenticatedReq;
  } catch (error) {
    return createErrorResponse(401, 'UNAUTHORIZED', error.message);
  }
}

export function requireRole(role: 'user' | 'admin') {
  return (req: AuthenticatedRequest): Response | null => {
    if (!req.user) {
      return createErrorResponse(401, 'UNAUTHORIZED', 'Authentication required');
    }
    
    if (req.user.role !== role && role === 'admin') {
      return createErrorResponse(403, 'FORBIDDEN', 'Admin access required');
    }
    
    return null;
  };
}
```

### ğŸ”’ ãƒ‘ã‚¹ãƒ¯ãƒ¼ãƒ‰ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£å®Ÿè£…

```typescript
// supabase/functions/shared/utils/password.ts
import { hash, compare } from 'https://deno.land/x/bcrypt@v0.4.1/mod.ts';

export class PasswordService {
  private static readonly SALT_ROUNDS = 12;
  
  static async hashPassword(password: string): Promise<string> {
    // ãƒ‘ã‚¹ãƒ¯ãƒ¼ãƒ‰å¼·åº¦ãƒã‚§ãƒƒã‚¯
    this.validatePasswordStrength(password);
    
    return await hash(password, this.SALT_ROUNDS);
  }
  
  static async verifyPassword(password: string, hashedPassword: string): Promise<boolean> {
    return await compare(password, hashedPassword);
  }
  
  private static validatePasswordStrength(password: string): void {
    const minLength = 8;
    const hasUpperCase = /[A-Z]/.test(password);
    const hasLowerCase = /[a-z]/.test(password);
    const hasNumbers = /\d/.test(password);
    const hasSpecialChar = /[!@#$%^&*(),.?":{}|<>]/.test(password);
    
    if (password.length < minLength) {
      throw new Error(`Password must be at least ${minLength} characters long`);
    }
    
    if (!hasUpperCase) {
      throw new Error('Password must contain at least one uppercase letter');
    }
    
    if (!hasLowerCase) {
      throw new Error('Password must contain at least one lowercase letter');
    }
    
    if (!hasNumbers) {
      throw new Error('Password must contain at least one number');
    }
    
    if (!hasSpecialChar) {
      throw new Error('Password must contain at least one special character');
    }
  }
}
```

---

## ğŸ¢ ç‰©ä»¶ç®¡ç†APIå®Ÿè£…

### ğŸ“‹ ç‰©ä»¶ãƒ‡ãƒ¼ã‚¿ãƒ¢ãƒ‡ãƒ«è¨­è¨ˆ

ç‰©ä»¶ç®¡ç†APIã¯ã€ä¸å‹•ç”£æŠ•è³‡ç®¡ç†ã®ä¸­æ ¸æ©Ÿèƒ½ã¨ã—ã¦ã€åŒ…æ‹¬çš„ãªç‰©ä»¶æƒ…å ±ã®ç®¡ç†ã€æ¤œç´¢ã€åˆ†ææ©Ÿèƒ½ã‚’æä¾›ã—ã¾ã™ã€‚ã‚¨ãƒ³ã‚¿ãƒ¼ãƒ—ãƒ©ã‚¤ã‚ºã‚°ãƒ¬ãƒ¼ãƒ‰ã®ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹ã‚¹ã‚­ãƒ¼ãƒã¨é€£æºã—ã€å‹å®‰å…¨æ€§ã¨ãƒ‡ãƒ¼ã‚¿æ•´åˆæ€§ã‚’ç¢ºä¿ã—ãŸå®Ÿè£…ã‚’è¡Œã„ã¾ã™ã€‚

```typescript
// supabase/functions/shared/schemas/property.ts
import { z } from 'https://deno.land/x/zod@v3.22.4/mod.ts';

export const PropertyTypeEnum = z.enum([
  'apartment',
  'house',
  'condo',
  'commercial',
  'land',
  'other'
]);

export const PropertyStatusEnum = z.enum([
  'owned',
  'under_contract',
  'for_sale',
  'sold',
  'rented',
  'vacant'
]);

export const CreatePropertySchema = z.object({
  name: z.string().min(1).max(255),
  address: z.string().min(1).max(500),
  property_type: PropertyTypeEnum,
  purchase_price: z.number().positive(),
  purchase_date: z.string().datetime(),
  current_value: z.number().positive().optional(),
  lot_size: z.number().positive().optional(),
  building_size: z.number().positive().optional(),
  year_built: z.number().int().min(1800).max(new Date().getFullYear()).optional(),
  bedrooms: z.number().int().min(0).optional(),
  bathrooms: z.number().min(0).optional(),
  parking_spaces: z.number().int().min(0).optional(),
  description: z.string().max(2000).optional(),
  status: PropertyStatusEnum.default('owned'),
  images: z.array(z.string().url()).max(20).optional(),
  documents: z.array(z.string().url()).max(50).optional(),
  metadata: z.record(z.any()).optional()
});

export const UpdatePropertySchema = CreatePropertySchema.partial();

export const PropertySearchSchema = z.object({
  query: z.string().optional(),
  property_type: PropertyTypeEnum.optional(),
  status: PropertyStatusEnum.optional(),
  min_price: z.number().positive().optional(),
  max_price: z.number().positive().optional(),
  min_size: z.number().positive().optional(),
  max_size: z.number().positive().optional(),
  location: z.string().optional(),
  page: z.number().int().min(1).default(1),
  limit: z.number().int().min(1).max(100).default(20),
  sort_by: z.enum(['name', 'purchase_price', 'purchase_date', 'current_value']).default('purchase_date'),
  sort_order: z.enum(['asc', 'desc']).default('desc')
});

export type CreatePropertyRequest = z.infer<typeof CreatePropertySchema>;
export type UpdatePropertyRequest = z.infer<typeof UpdatePropertySchema>;
export type PropertySearchRequest = z.infer<typeof PropertySearchSchema>;
```

### ğŸ—ï¸ ç‰©ä»¶CRUDæ“ä½œå®Ÿè£…

#### ç‰©ä»¶ä½œæˆAPI

```typescript
// supabase/functions/properties/create/index.ts
import { serve } from 'https://deno.land/std@0.208.0/http/server.ts';
import { corsHeaders } from '../../shared/middleware/cors.ts';
import { authMiddleware } from '../../shared/middleware/auth.ts';
import { validateRequest } from '../../shared/middleware/validation.ts';
import { CreatePropertySchema } from '../../shared/schemas/property.ts';
import { createSuccessResponse, createErrorResponse } from '../../shared/utils/response.ts';
import { DatabaseService } from '../../shared/utils/database.ts';

serve(async (req: Request) => {
  // CORSå¯¾å¿œ
  if (req.method === 'OPTIONS') {
    return new Response('ok', { headers: corsHeaders });
  }
  
  try {
    // èªè¨¼ãƒã‚§ãƒƒã‚¯
    const authResult = await authMiddleware(req);
    if (authResult instanceof Response) {
      return authResult;
    }
    
    // HTTPãƒ¡ã‚½ãƒƒãƒ‰ãƒã‚§ãƒƒã‚¯
    if (req.method !== 'POST') {
      return createErrorResponse(405, 'METHOD_NOT_ALLOWED', 'Only POST method is allowed');
    }
    
    // ãƒªã‚¯ã‚¨ã‚¹ãƒˆãƒœãƒ‡ã‚£ã®å–å¾—ã¨æ¤œè¨¼
    const body = await req.json();
    const validationResult = validateRequest(CreatePropertySchema, body);
    if (validationResult instanceof Response) {
      return validationResult;
    }
    
    const propertyData = validationResult;
    const userId = authResult.user!.id;
    
    // ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹ã«ç‰©ä»¶ã‚’ä½œæˆ
    const db = new DatabaseService();
    const property = await db.createProperty(userId, propertyData);
    
    // æˆåŠŸãƒ¬ã‚¹ãƒãƒ³ã‚¹
    return createSuccessResponse({
      property,
      message: 'Property created successfully'
    }, 201);
    
  } catch (error) {
    console.error('Property creation error:', error);
    
    if (error.message.includes('duplicate')) {
      return createErrorResponse(409, 'CONFLICT', 'Property with this name already exists');
    }
    
    return createErrorResponse(500, 'INTERNAL_SERVER_ERROR', 'Failed to create property');
  }
});
```

#### ç‰©ä»¶å–å¾—API

```typescript
// supabase/functions/properties/read/index.ts
import { serve } from 'https://deno.land/std@0.208.0/http/server.ts';
import { corsHeaders } from '../../shared/middleware/cors.ts';
import { authMiddleware } from '../../shared/middleware/auth.ts';
import { createSuccessResponse, createErrorResponse } from '../../shared/utils/response.ts';
import { DatabaseService } from '../../shared/utils/database.ts';

serve(async (req: Request) => {
  if (req.method === 'OPTIONS') {
    return new Response('ok', { headers: corsHeaders });
  }
  
  try {
    const authResult = await authMiddleware(req);
    if (authResult instanceof Response) {
      return authResult;
    }
    
    if (req.method !== 'GET') {
      return createErrorResponse(405, 'METHOD_NOT_ALLOWED', 'Only GET method is allowed');
    }
    
    const url = new URL(req.url);
    const propertyId = url.pathname.split('/').pop();
    const userId = authResult.user!.id;
    
    const db = new DatabaseService();
    
    if (propertyId && propertyId !== 'read') {
      // å˜ä¸€ç‰©ä»¶ã®å–å¾—
      const property = await db.getProperty(userId, propertyId);
      
      if (!property) {
        return createErrorResponse(404, 'NOT_FOUND', 'Property not found');
      }
      
      return createSuccessResponse({ property });
    } else {
      // ç‰©ä»¶ä¸€è¦§ã®å–å¾—
      const properties = await db.getProperties(userId);
      
      return createSuccessResponse({
        properties,
        total: properties.length
      });
    }
    
  } catch (error) {
    console.error('Property retrieval error:', error);
    return createErrorResponse(500, 'INTERNAL_SERVER_ERROR', 'Failed to retrieve property');
  }
});
```

#### ç‰©ä»¶æ›´æ–°API

```typescript
// supabase/functions/properties/update/index.ts
import { serve } from 'https://deno.land/std@0.208.0/http/server.ts';
import { corsHeaders } from '../../shared/middleware/cors.ts';
import { authMiddleware } from '../../shared/middleware/auth.ts';
import { validateRequest } from '../../shared/middleware/validation.ts';
import { UpdatePropertySchema } from '../../shared/schemas/property.ts';
import { createSuccessResponse, createErrorResponse } from '../../shared/utils/response.ts';
import { DatabaseService } from '../../shared/utils/database.ts';

serve(async (req: Request) => {
  if (req.method === 'OPTIONS') {
    return new Response('ok', { headers: corsHeaders });
  }
  
  try {
    const authResult = await authMiddleware(req);
    if (authResult instanceof Response) {
      return authResult;
    }
    
    if (req.method !== 'PUT' && req.method !== 'PATCH') {
      return createErrorResponse(405, 'METHOD_NOT_ALLOWED', 'Only PUT and PATCH methods are allowed');
    }
    
    const url = new URL(req.url);
    const propertyId = url.pathname.split('/').pop();
    
    if (!propertyId || propertyId === 'update') {
      return createErrorResponse(400, 'BAD_REQUEST', 'Property ID is required');
    }
    
    const body = await req.json();
    const validationResult = validateRequest(UpdatePropertySchema, body);
    if (validationResult instanceof Response) {
      return validationResult;
    }
    
    const updateData = validationResult;
    const userId = authResult.user!.id;
    
    const db = new DatabaseService();
    
    // ç‰©ä»¶ã®å­˜åœ¨ç¢ºèªã¨æ‰€æœ‰è€…ãƒã‚§ãƒƒã‚¯
    const existingProperty = await db.getProperty(userId, propertyId);
    if (!existingProperty) {
      return createErrorResponse(404, 'NOT_FOUND', 'Property not found');
    }
    
    // ç‰©ä»¶ã®æ›´æ–°
    const updatedProperty = await db.updateProperty(userId, propertyId, updateData);
    
    return createSuccessResponse({
      property: updatedProperty,
      message: 'Property updated successfully'
    });
    
  } catch (error) {
    console.error('Property update error:', error);
    return createErrorResponse(500, 'INTERNAL_SERVER_ERROR', 'Failed to update property');
  }
});
```

#### ç‰©ä»¶å‰Šé™¤API

```typescript
// supabase/functions/properties/delete/index.ts
import { serve } from 'https://deno.land/std@0.208.0/http/server.ts';
import { corsHeaders } from '../../shared/middleware/cors.ts';
import { authMiddleware } from '../../shared/middleware/auth.ts';
import { createSuccessResponse, createErrorResponse } from '../../shared/utils/response.ts';
import { DatabaseService } from '../../shared/utils/database.ts';

serve(async (req: Request) => {
  if (req.method === 'OPTIONS') {
    return new Response('ok', { headers: corsHeaders });
  }
  
  try {
    const authResult = await authMiddleware(req);
    if (authResult instanceof Response) {
      return authResult;
    }
    
    if (req.method !== 'DELETE') {
      return createErrorResponse(405, 'METHOD_NOT_ALLOWED', 'Only DELETE method is allowed');
    }
    
    const url = new URL(req.url);
    const propertyId = url.pathname.split('/').pop();
    
    if (!propertyId || propertyId === 'delete') {
      return createErrorResponse(400, 'BAD_REQUEST', 'Property ID is required');
    }
    
    const userId = authResult.user!.id;
    const db = new DatabaseService();
    
    // ç‰©ä»¶ã®å­˜åœ¨ç¢ºèªã¨æ‰€æœ‰è€…ãƒã‚§ãƒƒã‚¯
    const existingProperty = await db.getProperty(userId, propertyId);
    if (!existingProperty) {
      return createErrorResponse(404, 'NOT_FOUND', 'Property not found');
    }
    
    // é–¢é€£ãƒ‡ãƒ¼ã‚¿ã®ç¢ºèªï¼ˆå€Ÿå…¥ã€ãƒ¬ãƒ³ãƒˆãƒ­ãƒ¼ãƒ«ãªã©ï¼‰
    const hasRelatedData = await db.checkPropertyRelatedData(propertyId);
    if (hasRelatedData) {
      return createErrorResponse(409, 'CONFLICT', 'Cannot delete property with related loans or rent rolls');
    }
    
    // ç‰©ä»¶ã®å‰Šé™¤
    await db.deleteProperty(userId, propertyId);
    
    return createSuccessResponse({
      message: 'Property deleted successfully'
    });
    
  } catch (error) {
    console.error('Property deletion error:', error);
    return createErrorResponse(500, 'INTERNAL_SERVER_ERROR', 'Failed to delete property');
  }
});
```

### ğŸ” ç‰©ä»¶æ¤œç´¢APIå®Ÿè£…

```typescript
// supabase/functions/properties/search/index.ts
import { serve } from 'https://deno.land/std@0.208.0/http/server.ts';
import { corsHeaders } from '../../shared/middleware/cors.ts';
import { authMiddleware } from '../../shared/middleware/auth.ts';
import { validateRequest } from '../../shared/middleware/validation.ts';
import { PropertySearchSchema } from '../../shared/schemas/property.ts';
import { createSuccessResponse, createErrorResponse } from '../../shared/utils/response.ts';
import { DatabaseService } from '../../shared/utils/database.ts';

serve(async (req: Request) => {
  if (req.method === 'OPTIONS') {
    return new Response('ok', { headers: corsHeaders });
  }
  
  try {
    const authResult = await authMiddleware(req);
    if (authResult instanceof Response) {
      return authResult;
    }
    
    if (req.method !== 'GET') {
      return createErrorResponse(405, 'METHOD_NOT_ALLOWED', 'Only GET method is allowed');
    }
    
    const url = new URL(req.url);
    const searchParams = Object.fromEntries(url.searchParams.entries());
    
    // æ•°å€¤ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ã®å¤‰æ›
    ['min_price', 'max_price', 'min_size', 'max_size', 'page', 'limit'].forEach(param => {
      if (searchParams[param]) {
        searchParams[param] = Number(searchParams[param]);
      }
    });
    
    const validationResult = validateRequest(PropertySearchSchema, searchParams);
    if (validationResult instanceof Response) {
      return validationResult;
    }
    
    const searchCriteria = validationResult;
    const userId = authResult.user!.id;
    
    const db = new DatabaseService();
    const searchResult = await db.searchProperties(userId, searchCriteria);
    
    return createSuccessResponse({
      properties: searchResult.properties,
      pagination: {
        page: searchCriteria.page,
        limit: searchCriteria.limit,
        total: searchResult.total,
        totalPages: Math.ceil(searchResult.total / searchCriteria.limit)
      },
      filters: searchCriteria
    });
    
  } catch (error) {
    console.error('Property search error:', error);
    return createErrorResponse(500, 'INTERNAL_SERVER_ERROR', 'Failed to search properties');
  }
});
```



---

## ğŸ’° å€Ÿå…¥ç®¡ç†APIå®Ÿè£…

### ğŸ“Š å€Ÿå…¥ãƒ‡ãƒ¼ã‚¿ãƒ¢ãƒ‡ãƒ«è¨­è¨ˆ

å€Ÿå…¥ç®¡ç†APIã¯ã€ä¸å‹•ç”£æŠ•è³‡ã«ãŠã‘ã‚‹èè³‡æƒ…å ±ã®åŒ…æ‹¬çš„ãªç®¡ç†ã‚’æä¾›ã—ã¾ã™ã€‚è¤‡é›‘ãªé‡‘èè¨ˆç®—ã€è¿”æ¸ˆã‚¹ã‚±ã‚¸ãƒ¥ãƒ¼ãƒ«ç®¡ç†ã€é‡‘åˆ©å¤‰å‹•å¯¾å¿œãªã©ã€ã‚¨ãƒ³ã‚¿ãƒ¼ãƒ—ãƒ©ã‚¤ã‚ºãƒ¬ãƒ™ãƒ«ã®é‡‘èæ©Ÿèƒ½ã‚’å®Ÿè£…ã—ã¾ã™ã€‚

```typescript
// supabase/functions/shared/schemas/loan.ts
import { z } from 'https://deno.land/x/zod@v3.22.4/mod.ts';

export const LoanTypeEnum = z.enum([
  'fixed_rate',
  'variable_rate',
  'interest_only',
  'balloon',
  'construction',
  'bridge',
  'other'
]);

export const LoanStatusEnum = z.enum([
  'active',
  'paid_off',
  'defaulted',
  'refinanced',
  'under_review'
]);

export const CreateLoanSchema = z.object({
  property_id: z.string().uuid(),
  lender_name: z.string().min(1).max(255),
  loan_amount: z.number().positive(),
  interest_rate: z.number().min(0).max(100),
  loan_term_months: z.number().int().positive(),
  loan_type: LoanTypeEnum,
  start_date: z.string().datetime(),
  monthly_payment: z.number().positive(),
  down_payment: z.number().min(0).optional(),
  closing_costs: z.number().min(0).optional(),
  points: z.number().min(0).optional(),
  prepayment_penalty: z.boolean().default(false),
  escrow_account: z.boolean().default(false),
  property_taxes_monthly: z.number().min(0).optional(),
  insurance_monthly: z.number().min(0).optional(),
  pmi_monthly: z.number().min(0).optional(),
  status: LoanStatusEnum.default('active'),
  notes: z.string().max(2000).optional(),
  documents: z.array(z.string().url()).max(50).optional(),
  metadata: z.record(z.any()).optional()
});

export const UpdateLoanSchema = CreateLoanSchema.partial().omit({ property_id: true });

export const LoanPaymentSchema = z.object({
  payment_date: z.string().datetime(),
  principal_amount: z.number().min(0),
  interest_amount: z.number().min(0),
  escrow_amount: z.number().min(0).optional(),
  total_amount: z.number().positive(),
  payment_method: z.enum(['bank_transfer', 'check', 'online', 'auto_pay']).optional(),
  notes: z.string().max(500).optional()
});

export const LoanCalculationSchema = z.object({
  loan_amount: z.number().positive(),
  interest_rate: z.number().min(0).max(100),
  loan_term_months: z.number().int().positive(),
  start_date: z.string().datetime().optional()
});

export type CreateLoanRequest = z.infer<typeof CreateLoanSchema>;
export type UpdateLoanRequest = z.infer<typeof UpdateLoanSchema>;
export type LoanPaymentRequest = z.infer<typeof LoanPaymentSchema>;
export type LoanCalculationRequest = z.infer<typeof LoanCalculationSchema>;
```

### ğŸ¦ å€Ÿå…¥CRUDæ“ä½œå®Ÿè£…

#### å€Ÿå…¥ä½œæˆAPI

```typescript
// supabase/functions/loans/create/index.ts
import { serve } from 'https://deno.land/std@0.208.0/http/server.ts';
import { corsHeaders } from '../../shared/middleware/cors.ts';
import { authMiddleware } from '../../shared/middleware/auth.ts';
import { validateRequest } from '../../shared/middleware/validation.ts';
import { CreateLoanSchema } from '../../shared/schemas/loan.ts';
import { createSuccessResponse, createErrorResponse } from '../../shared/utils/response.ts';
import { DatabaseService } from '../../shared/utils/database.ts';
import { LoanCalculationService } from '../../shared/utils/loan-calculations.ts';

serve(async (req: Request) => {
  if (req.method === 'OPTIONS') {
    return new Response('ok', { headers: corsHeaders });
  }
  
  try {
    const authResult = await authMiddleware(req);
    if (authResult instanceof Response) {
      return authResult;
    }
    
    if (req.method !== 'POST') {
      return createErrorResponse(405, 'METHOD_NOT_ALLOWED', 'Only POST method is allowed');
    }
    
    const body = await req.json();
    const validationResult = validateRequest(CreateLoanSchema, body);
    if (validationResult instanceof Response) {
      return validationResult;
    }
    
    const loanData = validationResult;
    const userId = authResult.user!.id;
    
    const db = new DatabaseService();
    
    // ç‰©ä»¶ã®å­˜åœ¨ç¢ºèªã¨æ‰€æœ‰è€…ãƒã‚§ãƒƒã‚¯
    const property = await db.getProperty(userId, loanData.property_id);
    if (!property) {
      return createErrorResponse(404, 'NOT_FOUND', 'Property not found');
    }
    
    // å€Ÿå…¥è¨ˆç®—ã®å®Ÿè¡Œ
    const calculationService = new LoanCalculationService();
    const loanCalculations = calculationService.calculateLoanDetails(loanData);
    
    // å€Ÿå…¥ãƒ‡ãƒ¼ã‚¿ã®ä½œæˆ
    const loan = await db.createLoan(userId, {
      ...loanData,
      ...loanCalculations
    });
    
    // è¿”æ¸ˆã‚¹ã‚±ã‚¸ãƒ¥ãƒ¼ãƒ«ã®ç”Ÿæˆ
    const paymentSchedule = calculationService.generatePaymentSchedule(loan);
    await db.createPaymentSchedule(loan.id, paymentSchedule);
    
    return createSuccessResponse({
      loan,
      payment_schedule: paymentSchedule.slice(0, 12), // æœ€åˆã®12ãƒ¶æœˆåˆ†ã‚’è¿”ã™
      message: 'Loan created successfully'
    }, 201);
    
  } catch (error) {
    console.error('Loan creation error:', error);
    return createErrorResponse(500, 'INTERNAL_SERVER_ERROR', 'Failed to create loan');
  }
});
```

#### å€Ÿå…¥è¨ˆç®—ã‚µãƒ¼ãƒ“ã‚¹

```typescript
// supabase/functions/shared/utils/loan-calculations.ts
export interface LoanCalculationResult {
  total_interest: number;
  total_payments: number;
  monthly_principal_interest: number;
  loan_to_value_ratio: number;
  debt_service_coverage_ratio?: number;
}

export interface PaymentScheduleItem {
  payment_number: number;
  payment_date: string;
  beginning_balance: number;
  principal_payment: number;
  interest_payment: number;
  total_payment: number;
  ending_balance: number;
  cumulative_interest: number;
}

export class LoanCalculationService {
  calculateLoanDetails(loanData: any): LoanCalculationResult {
    const { loan_amount, interest_rate, loan_term_months, monthly_payment } = loanData;
    const monthlyRate = interest_rate / 100 / 12;
    
    // æœˆæ¬¡å…ƒåˆ©å‡ç­‰è¿”æ¸ˆé¡ã®è¨ˆç®—ï¼ˆæŒ‡å®šã•ã‚Œã¦ã„ãªã„å ´åˆï¼‰
    let calculatedMonthlyPayment = monthly_payment;
    if (!monthly_payment) {
      calculatedMonthlyPayment = this.calculateMonthlyPayment(
        loan_amount,
        monthlyRate,
        loan_term_months
      );
    }
    
    // ç·åˆ©æ¯ã®è¨ˆç®—
    const totalPayments = calculatedMonthlyPayment * loan_term_months;
    const totalInterest = totalPayments - loan_amount;
    
    // LTVæ¯”ç‡ã®è¨ˆç®—ï¼ˆç‰©ä»¶ä¾¡æ ¼ãŒå¿…è¦ï¼‰
    const loanToValueRatio = (loan_amount / (loanData.property_value || loan_amount)) * 100;
    
    return {
      total_interest: totalInterest,
      total_payments: totalPayments,
      monthly_principal_interest: calculatedMonthlyPayment,
      loan_to_value_ratio: loanToValueRatio
    };
  }
  
  private calculateMonthlyPayment(principal: number, monthlyRate: number, termMonths: number): number {
    if (monthlyRate === 0) {
      return principal / termMonths;
    }
    
    const numerator = principal * monthlyRate * Math.pow(1 + monthlyRate, termMonths);
    const denominator = Math.pow(1 + monthlyRate, termMonths) - 1;
    
    return numerator / denominator;
  }
  
  generatePaymentSchedule(loan: any): PaymentScheduleItem[] {
    const schedule: PaymentScheduleItem[] = [];
    const monthlyRate = loan.interest_rate / 100 / 12;
    let remainingBalance = loan.loan_amount;
    let cumulativeInterest = 0;
    
    const startDate = new Date(loan.start_date);
    
    for (let i = 1; i <= loan.loan_term_months; i++) {
      const paymentDate = new Date(startDate);
      paymentDate.setMonth(paymentDate.getMonth() + i - 1);
      
      const interestPayment = remainingBalance * monthlyRate;
      const principalPayment = loan.monthly_payment - interestPayment;
      const endingBalance = Math.max(0, remainingBalance - principalPayment);
      
      cumulativeInterest += interestPayment;
      
      schedule.push({
        payment_number: i,
        payment_date: paymentDate.toISOString(),
        beginning_balance: remainingBalance,
        principal_payment: principalPayment,
        interest_payment: interestPayment,
        total_payment: loan.monthly_payment,
        ending_balance: endingBalance,
        cumulative_interest: cumulativeInterest
      });
      
      remainingBalance = endingBalance;
      
      if (remainingBalance <= 0.01) {
        break;
      }
    }
    
    return schedule;
  }
  
  calculateRefinanceAnalysis(currentLoan: any, newLoanTerms: any): any {
    const currentSchedule = this.generatePaymentSchedule(currentLoan);
    const newSchedule = this.generatePaymentSchedule(newLoanTerms);
    
    const remainingPayments = currentSchedule.filter(p => 
      new Date(p.payment_date) > new Date()
    );
    
    const currentRemainingInterest = remainingPayments.reduce(
      (sum, payment) => sum + payment.interest_payment, 0
    );
    
    const newTotalInterest = newSchedule.reduce(
      (sum, payment) => sum + payment.interest_payment, 0
    );
    
    const interestSavings = currentRemainingInterest - newTotalInterest;
    const closingCosts = newLoanTerms.closing_costs || 0;
    const netSavings = interestSavings - closingCosts;
    
    return {
      current_remaining_interest: currentRemainingInterest,
      new_total_interest: newTotalInterest,
      interest_savings: interestSavings,
      closing_costs: closingCosts,
      net_savings: netSavings,
      break_even_months: closingCosts / (currentLoan.monthly_payment - newLoanTerms.monthly_payment),
      recommendation: netSavings > 0 ? 'refinance' : 'keep_current'
    };
  }
}
```

---

## ğŸ  ãƒ¬ãƒ³ãƒˆãƒ­ãƒ¼ãƒ«ç®¡ç†APIå®Ÿè£…

### ğŸ“‹ ãƒ¬ãƒ³ãƒˆãƒ­ãƒ¼ãƒ«ãƒ‡ãƒ¼ã‚¿ãƒ¢ãƒ‡ãƒ«è¨­è¨ˆ

ãƒ¬ãƒ³ãƒˆãƒ­ãƒ¼ãƒ«ç®¡ç†APIã¯ã€è³ƒè²¸åå…¥ã®è©³ç´°ãªè¿½è·¡ã¨åˆ†ææ©Ÿèƒ½ã‚’æä¾›ã—ã¾ã™ã€‚ãƒ†ãƒŠãƒ³ãƒˆç®¡ç†ã€è³ƒæ–™åå…¥ã€ç©ºå®¤ç‡åˆ†æã€åç›Šæ€§è©•ä¾¡ãªã©ã€ãƒ—ãƒ­ãƒ•ã‚§ãƒƒã‚·ãƒ§ãƒŠãƒ«ãªä¸å‹•ç”£ç®¡ç†ã«å¿…è¦ãªå…¨æ©Ÿèƒ½ã‚’åŒ…å«ã—ã¾ã™ã€‚

```typescript
// supabase/functions/shared/schemas/rent-roll.ts
import { z } from 'https://deno.land/x/zod@v3.22.4/mod.ts';

export const UnitTypeEnum = z.enum([
  'studio',
  '1br',
  '2br',
  '3br',
  '4br',
  'commercial',
  'parking',
  'storage',
  'other'
]);

export const LeaseStatusEnum = z.enum([
  'active',
  'expired',
  'month_to_month',
  'notice_given',
  'vacant',
  'maintenance'
]);

export const CreateRentRollSchema = z.object({
  property_id: z.string().uuid(),
  unit_number: z.string().min(1).max(50),
  unit_type: UnitTypeEnum,
  square_footage: z.number().positive().optional(),
  tenant_name: z.string().max(255).optional(),
  lease_start_date: z.string().datetime().optional(),
  lease_end_date: z.string().datetime().optional(),
  monthly_rent: z.number().min(0),
  security_deposit: z.number().min(0).optional(),
  pet_deposit: z.number().min(0).optional(),
  lease_status: LeaseStatusEnum.default('vacant'),
  rent_due_date: z.number().int().min(1).max(31).default(1),
  late_fee: z.number().min(0).optional(),
  pet_fee: z.number().min(0).optional(),
  parking_fee: z.number().min(0).optional(),
  utilities_included: z.array(z.string()).optional(),
  tenant_email: z.string().email().optional(),
  tenant_phone: z.string().max(20).optional(),
  emergency_contact: z.string().max(255).optional(),
  move_in_date: z.string().datetime().optional(),
  move_out_date: z.string().datetime().optional(),
  notes: z.string().max(2000).optional(),
  documents: z.array(z.string().url()).max(50).optional(),
  metadata: z.record(z.any()).optional()
});

export const UpdateRentRollSchema = CreateRentRollSchema.partial().omit({ property_id: true });

export const RentPaymentSchema = z.object({
  rent_roll_id: z.string().uuid(),
  payment_date: z.string().datetime(),
  amount_paid: z.number().positive(),
  payment_method: z.enum(['cash', 'check', 'bank_transfer', 'online', 'money_order']),
  late_fee_paid: z.number().min(0).optional(),
  partial_payment: z.boolean().default(false),
  payment_reference: z.string().max(100).optional(),
  notes: z.string().max(500).optional()
});

export const VacancyReportSchema = z.object({
  property_id: z.string().uuid().optional(),
  start_date: z.string().datetime(),
  end_date: z.string().datetime(),
  unit_type: UnitTypeEnum.optional()
});

export type CreateRentRollRequest = z.infer<typeof CreateRentRollSchema>;
export type UpdateRentRollRequest = z.infer<typeof UpdateRentRollSchema>;
export type RentPaymentRequest = z.infer<typeof RentPaymentSchema>;
export type VacancyReportRequest = z.infer<typeof VacancyReportSchema>;
```

### ğŸ¢ ãƒ¬ãƒ³ãƒˆãƒ­ãƒ¼ãƒ«CRUDæ“ä½œå®Ÿè£…

#### ãƒ¬ãƒ³ãƒˆãƒ­ãƒ¼ãƒ«ä½œæˆAPI

```typescript
// supabase/functions/rent-rolls/create/index.ts
import { serve } from 'https://deno.land/std@0.208.0/http/server.ts';
import { corsHeaders } from '../../shared/middleware/cors.ts';
import { authMiddleware } from '../../shared/middleware/auth.ts';
import { validateRequest } from '../../shared/middleware/validation.ts';
import { CreateRentRollSchema } from '../../shared/schemas/rent-roll.ts';
import { createSuccessResponse, createErrorResponse } from '../../shared/utils/response.ts';
import { DatabaseService } from '../../shared/utils/database.ts';
import { RentRollAnalyticsService } from '../../shared/utils/rent-roll-analytics.ts';

serve(async (req: Request) => {
  if (req.method === 'OPTIONS') {
    return new Response('ok', { headers: corsHeaders });
  }
  
  try {
    const authResult = await authMiddleware(req);
    if (authResult instanceof Response) {
      return authResult;
    }
    
    if (req.method !== 'POST') {
      return createErrorResponse(405, 'METHOD_NOT_ALLOWED', 'Only POST method is allowed');
    }
    
    const body = await req.json();
    const validationResult = validateRequest(CreateRentRollSchema, body);
    if (validationResult instanceof Response) {
      return validationResult;
    }
    
    const rentRollData = validationResult;
    const userId = authResult.user!.id;
    
    const db = new DatabaseService();
    
    // ç‰©ä»¶ã®å­˜åœ¨ç¢ºèªã¨æ‰€æœ‰è€…ãƒã‚§ãƒƒã‚¯
    const property = await db.getProperty(userId, rentRollData.property_id);
    if (!property) {
      return createErrorResponse(404, 'NOT_FOUND', 'Property not found');
    }
    
    // åŒä¸€ç‰©ä»¶å†…ã§ã®ãƒ¦ãƒ‹ãƒƒãƒˆç•ªå·é‡è¤‡ãƒã‚§ãƒƒã‚¯
    const existingUnit = await db.getRentRollByUnit(
      rentRollData.property_id,
      rentRollData.unit_number
    );
    if (existingUnit) {
      return createErrorResponse(409, 'CONFLICT', 'Unit number already exists for this property');
    }
    
    // ãƒ¬ãƒ³ãƒˆãƒ­ãƒ¼ãƒ«ã®ä½œæˆ
    const rentRoll = await db.createRentRoll(userId, rentRollData);
    
    // åˆ†æãƒ‡ãƒ¼ã‚¿ã®è¨ˆç®—
    const analyticsService = new RentRollAnalyticsService();
    const analytics = await analyticsService.calculateUnitAnalytics(rentRoll);
    
    return createSuccessResponse({
      rent_roll: rentRoll,
      analytics: analytics,
      message: 'Rent roll created successfully'
    }, 201);
    
  } catch (error) {
    console.error('Rent roll creation error:', error);
    return createErrorResponse(500, 'INTERNAL_SERVER_ERROR', 'Failed to create rent roll');
  }
});
```

#### ãƒ¬ãƒ³ãƒˆãƒ­ãƒ¼ãƒ«åˆ†æã‚µãƒ¼ãƒ“ã‚¹

```typescript
// supabase/functions/shared/utils/rent-roll-analytics.ts
export interface UnitAnalytics {
  monthly_gross_income: number;
  annual_gross_income: number;
  occupancy_rate: number;
  rent_per_sqft: number;
  lease_expiration_risk: 'low' | 'medium' | 'high';
  market_rent_comparison?: number;
}

export interface PropertyAnalytics {
  total_units: number;
  occupied_units: number;
  vacant_units: number;
  occupancy_rate: number;
  total_monthly_income: number;
  total_annual_income: number;
  average_rent_per_unit: number;
  average_rent_per_sqft: number;
  lease_expiration_schedule: LeaseExpirationItem[];
  vacancy_loss: number;
  effective_gross_income: number;
}

export interface LeaseExpirationItem {
  month: string;
  expiring_leases: number;
  expiring_income: number;
  percentage_of_income: number;
}

export class RentRollAnalyticsService {
  async calculateUnitAnalytics(rentRoll: any): Promise<UnitAnalytics> {
    const monthlyGrossIncome = this.calculateMonthlyIncome(rentRoll);
    const annualGrossIncome = monthlyGrossIncome * 12;
    const occupancyRate = rentRoll.lease_status === 'active' ? 100 : 0;
    const rentPerSqft = rentRoll.square_footage 
      ? rentRoll.monthly_rent / rentRoll.square_footage 
      : 0;
    
    const leaseExpirationRisk = this.assessLeaseExpirationRisk(rentRoll);
    
    return {
      monthly_gross_income: monthlyGrossIncome,
      annual_gross_income: annualGrossIncome,
      occupancy_rate: occupancyRate,
      rent_per_sqft: rentPerSqft,
      lease_expiration_risk: leaseExpirationRisk
    };
  }
  
  async calculatePropertyAnalytics(propertyId: string, rentRolls: any[]): Promise<PropertyAnalytics> {
    const totalUnits = rentRolls.length;
    const occupiedUnits = rentRolls.filter(rr => 
      ['active', 'month_to_month'].includes(rr.lease_status)
    ).length;
    const vacantUnits = totalUnits - occupiedUnits;
    const occupancyRate = totalUnits > 0 ? (occupiedUnits / totalUnits) * 100 : 0;
    
    const totalMonthlyIncome = rentRolls.reduce((sum, rr) => {
      return sum + this.calculateMonthlyIncome(rr);
    }, 0);
    
    const totalAnnualIncome = totalMonthlyIncome * 12;
    const averageRentPerUnit = occupiedUnits > 0 ? totalMonthlyIncome / occupiedUnits : 0;
    
    const totalSquareFootage = rentRolls.reduce((sum, rr) => 
      sum + (rr.square_footage || 0), 0
    );
    const averageRentPerSqft = totalSquareFootage > 0 
      ? totalMonthlyIncome / totalSquareFootage 
      : 0;
    
    const leaseExpirationSchedule = this.calculateLeaseExpirationSchedule(rentRolls);
    const vacancyLoss = this.calculateVacancyLoss(rentRolls);
    const effectiveGrossIncome = totalAnnualIncome - vacancyLoss;
    
    return {
      total_units: totalUnits,
      occupied_units: occupiedUnits,
      vacant_units: vacantUnits,
      occupancy_rate: occupancyRate,
      total_monthly_income: totalMonthlyIncome,
      total_annual_income: totalAnnualIncome,
      average_rent_per_unit: averageRentPerUnit,
      average_rent_per_sqft: averageRentPerSqft,
      lease_expiration_schedule: leaseExpirationSchedule,
      vacancy_loss: vacancyLoss,
      effective_gross_income: effectiveGrossIncome
    };
  }
  
  private calculateMonthlyIncome(rentRoll: any): number {
    if (!['active', 'month_to_month'].includes(rentRoll.lease_status)) {
      return 0;
    }
    
    return (rentRoll.monthly_rent || 0) + 
           (rentRoll.pet_fee || 0) + 
           (rentRoll.parking_fee || 0);
  }
  
  private assessLeaseExpirationRisk(rentRoll: any): 'low' | 'medium' | 'high' {
    if (!rentRoll.lease_end_date || rentRoll.lease_status !== 'active') {
      return 'low';
    }
    
    const endDate = new Date(rentRoll.lease_end_date);
    const now = new Date();
    const monthsUntilExpiration = (endDate.getTime() - now.getTime()) / (1000 * 60 * 60 * 24 * 30);
    
    if (monthsUntilExpiration <= 3) {
      return 'high';
    } else if (monthsUntilExpiration <= 6) {
      return 'medium';
    } else {
      return 'low';
    }
  }
  
  private calculateLeaseExpirationSchedule(rentRolls: any[]): LeaseExpirationItem[] {
    const schedule: { [key: string]: LeaseExpirationItem } = {};
    const totalMonthlyIncome = rentRolls.reduce((sum, rr) => 
      sum + this.calculateMonthlyIncome(rr), 0
    );
    
    rentRolls.forEach(rentRoll => {
      if (rentRoll.lease_end_date && rentRoll.lease_status === 'active') {
        const endDate = new Date(rentRoll.lease_end_date);
        const monthKey = `${endDate.getFullYear()}-${String(endDate.getMonth() + 1).padStart(2, '0')}`;
        
        if (!schedule[monthKey]) {
          schedule[monthKey] = {
            month: monthKey,
            expiring_leases: 0,
            expiring_income: 0,
            percentage_of_income: 0
          };
        }
        
        schedule[monthKey].expiring_leases += 1;
        schedule[monthKey].expiring_income += this.calculateMonthlyIncome(rentRoll);
      }
    });
    
    // ãƒ‘ãƒ¼ã‚»ãƒ³ãƒ†ãƒ¼ã‚¸ã®è¨ˆç®—
    Object.values(schedule).forEach(item => {
      item.percentage_of_income = totalMonthlyIncome > 0 
        ? (item.expiring_income / totalMonthlyIncome) * 100 
        : 0;
    });
    
    return Object.values(schedule).sort((a, b) => a.month.localeCompare(b.month));
  }
  
  private calculateVacancyLoss(rentRolls: any[]): number {
    // éå»12ãƒ¶æœˆã®ç©ºå®¤æå¤±ã‚’è¨ˆç®—
    const vacantUnits = rentRolls.filter(rr => rr.lease_status === 'vacant');
    const averageVacantRent = vacantUnits.reduce((sum, rr) => sum + (rr.monthly_rent || 0), 0) / 
                             Math.max(vacantUnits.length, 1);
    
    // ç°¡ç•¥åŒ–ã•ã‚ŒãŸè¨ˆç®—ï¼ˆå®Ÿéš›ã«ã¯ã‚ˆã‚Šè¤‡é›‘ãªå±¥æ­´åˆ†æãŒå¿…è¦ï¼‰
    return averageVacantRent * vacantUnits.length * 12;
  }
  
  async generateVacancyReport(criteria: any): Promise<any> {
    const db = new DatabaseService();
    const rentRolls = await db.getRentRollsForReport(criteria);
    
    const reportPeriodDays = (new Date(criteria.end_date).getTime() - 
                             new Date(criteria.start_date).getTime()) / (1000 * 60 * 60 * 24);
    
    const vacancyData = rentRolls.map(rr => {
      const vacantDays = this.calculateVacantDays(rr, criteria.start_date, criteria.end_date);
      const vacancyRate = (vacantDays / reportPeriodDays) * 100;
      const lostIncome = (rr.monthly_rent || 0) * (vacantDays / 30);
      
      return {
        unit_number: rr.unit_number,
        unit_type: rr.unit_type,
        monthly_rent: rr.monthly_rent,
        vacant_days: vacantDays,
        vacancy_rate: vacancyRate,
        lost_income: lostIncome
      };
    });
    
    const totalLostIncome = vacancyData.reduce((sum, unit) => sum + unit.lost_income, 0);
    const averageVacancyRate = vacancyData.reduce((sum, unit) => sum + unit.vacancy_rate, 0) / 
                              Math.max(vacancyData.length, 1);
    
    return {
      report_period: {
        start_date: criteria.start_date,
        end_date: criteria.end_date,
        days: reportPeriodDays
      },
      summary: {
        total_units: vacancyData.length,
        average_vacancy_rate: averageVacancyRate,
        total_lost_income: totalLostIncome
      },
      unit_details: vacancyData
    };
  }
  
  private calculateVacantDays(rentRoll: any, startDate: string, endDate: string): number {
    // ç°¡ç•¥åŒ–ã•ã‚ŒãŸè¨ˆç®—ï¼ˆå®Ÿéš›ã«ã¯ã‚ˆã‚Šè©³ç´°ãªå±¥æ­´è¿½è·¡ãŒå¿…è¦ï¼‰
    if (rentRoll.lease_status === 'vacant') {
      return (new Date(endDate).getTime() - new Date(startDate).getTime()) / (1000 * 60 * 60 * 24);
    }
    return 0;
  }
}
```

---

## ğŸ‘¤ ãƒ¦ãƒ¼ã‚¶ãƒ¼ç®¡ç†APIå®Ÿè£…

### ğŸ” ãƒ¦ãƒ¼ã‚¶ãƒ¼ãƒ‡ãƒ¼ã‚¿ãƒ¢ãƒ‡ãƒ«è¨­è¨ˆ

ãƒ¦ãƒ¼ã‚¶ãƒ¼ç®¡ç†APIã¯ã€èªè¨¼ã‚·ã‚¹ãƒ†ãƒ ã¨é€£æºã—ã¦ãƒ¦ãƒ¼ã‚¶ãƒ¼ãƒ—ãƒ­ãƒ•ã‚¡ã‚¤ãƒ«ã€è¨­å®šã€æ¨©é™ç®¡ç†ã‚’æä¾›ã—ã¾ã™ã€‚GDPRæº–æ‹ ã®ãƒ‡ãƒ¼ã‚¿ç®¡ç†ã¨ãƒ—ãƒ©ã‚¤ãƒã‚·ãƒ¼ä¿è­·æ©Ÿèƒ½ã‚’å«ã‚€åŒ…æ‹¬çš„ãªå®Ÿè£…ã‚’è¡Œã„ã¾ã™ã€‚

```typescript
// supabase/functions/shared/schemas/user.ts
import { z } from 'https://deno.land/x/zod@v3.22.4/mod.ts';

export const UserRoleEnum = z.enum(['user', 'admin']);

export const CreateUserSchema = z.object({
  email: z.string().email(),
  password: z.string().min(8),
  first_name: z.string().min(1).max(100),
  last_name: z.string().min(1).max(100),
  phone: z.string().max(20).optional(),
  company: z.string().max(255).optional(),
  role: UserRoleEnum.default('user')
});

export const UpdateUserProfileSchema = z.object({
  first_name: z.string().min(1).max(100).optional(),
  last_name: z.string().min(1).max(100).optional(),
  phone: z.string().max(20).optional(),
  company: z.string().max(255).optional(),
  avatar_url: z.string().url().optional(),
  timezone: z.string().max(50).optional(),
  language: z.string().max(10).optional(),
  notification_preferences: z.object({
    email_notifications: z.boolean().default(true),
    sms_notifications: z.boolean().default(false),
    push_notifications: z.boolean().default(true),
    marketing_emails: z.boolean().default(false)
  }).optional()
});

export const ChangePasswordSchema = z.object({
  current_password: z.string(),
  new_password: z.string().min(8),
  confirm_password: z.string()
}).refine(data => data.new_password === data.confirm_password, {
  message: "Passwords don't match",
  path: ["confirm_password"]
});

export const UserPreferencesSchema = z.object({
  dashboard_layout: z.enum(['grid', 'list']).default('grid'),
  default_currency: z.string().length(3).default('USD'),
  date_format: z.enum(['MM/DD/YYYY', 'DD/MM/YYYY', 'YYYY-MM-DD']).default('MM/DD/YYYY'),
  number_format: z.enum(['US', 'EU']).default('US'),
  theme: z.enum(['light', 'dark', 'auto']).default('light'),
  items_per_page: z.number().int().min(10).max(100).default(20)
});

export type CreateUserRequest = z.infer<typeof CreateUserSchema>;
export type UpdateUserProfileRequest = z.infer<typeof UpdateUserProfileSchema>;
export type ChangePasswordRequest = z.infer<typeof ChangePasswordSchema>;
export type UserPreferencesRequest = z.infer<typeof UserPreferencesSchema>;
```

### ğŸ‘¤ ãƒ¦ãƒ¼ã‚¶ãƒ¼ãƒ—ãƒ­ãƒ•ã‚¡ã‚¤ãƒ«ç®¡ç†å®Ÿè£…

#### ãƒ¦ãƒ¼ã‚¶ãƒ¼ãƒ—ãƒ­ãƒ•ã‚¡ã‚¤ãƒ«å–å¾—API

```typescript
// supabase/functions/users/profile/index.ts
import { serve } from 'https://deno.land/std@0.208.0/http/server.ts';
import { corsHeaders } from '../../shared/middleware/cors.ts';
import { authMiddleware } from '../../shared/middleware/auth.ts';
import { createSuccessResponse, createErrorResponse } from '../../shared/utils/response.ts';
import { DatabaseService } from '../../shared/utils/database.ts';

serve(async (req: Request) => {
  if (req.method === 'OPTIONS') {
    return new Response('ok', { headers: corsHeaders });
  }
  
  try {
    const authResult = await authMiddleware(req);
    if (authResult instanceof Response) {
      return authResult;
    }
    
    if (req.method !== 'GET') {
      return createErrorResponse(405, 'METHOD_NOT_ALLOWED', 'Only GET method is allowed');
    }
    
    const userId = authResult.user!.id;
    const db = new DatabaseService();
    
    const userProfile = await db.getUserProfile(userId);
    if (!userProfile) {
      return createErrorResponse(404, 'NOT_FOUND', 'User profile not found');
    }
    
    // ã‚»ãƒ³ã‚·ãƒ†ã‚£ãƒ–æƒ…å ±ã‚’é™¤å¤–
    const { password_hash, ...safeProfile } = userProfile;
    
    return createSuccessResponse({
      user: safeProfile
    });
    
  } catch (error) {
    console.error('User profile retrieval error:', error);
    return createErrorResponse(500, 'INTERNAL_SERVER_ERROR', 'Failed to retrieve user profile');
  }
});
```

#### ãƒ¦ãƒ¼ã‚¶ãƒ¼ãƒ—ãƒ­ãƒ•ã‚¡ã‚¤ãƒ«æ›´æ–°API

```typescript
// supabase/functions/users/update/index.ts
import { serve } from 'https://deno.land/std@0.208.0/http/server.ts';
import { corsHeaders } from '../../shared/middleware/cors.ts';
import { authMiddleware } from '../../shared/middleware/auth.ts';
import { validateRequest } from '../../shared/middleware/validation.ts';
import { UpdateUserProfileSchema } from '../../shared/schemas/user.ts';
import { createSuccessResponse, createErrorResponse } from '../../shared/utils/response.ts';
import { DatabaseService } from '../../shared/utils/database.ts';

serve(async (req: Request) => {
  if (req.method === 'OPTIONS') {
    return new Response('ok', { headers: corsHeaders });
  }
  
  try {
    const authResult = await authMiddleware(req);
    if (authResult instanceof Response) {
      return authResult;
    }
    
    if (req.method !== 'PUT' && req.method !== 'PATCH') {
      return createErrorResponse(405, 'METHOD_NOT_ALLOWED', 'Only PUT and PATCH methods are allowed');
    }
    
    const body = await req.json();
    const validationResult = validateRequest(UpdateUserProfileSchema, body);
    if (validationResult instanceof Response) {
      return validationResult;
    }
    
    const updateData = validationResult;
    const userId = authResult.user!.id;
    
    const db = new DatabaseService();
    const updatedProfile = await db.updateUserProfile(userId, updateData);
    
    // ã‚»ãƒ³ã‚·ãƒ†ã‚£ãƒ–æƒ…å ±ã‚’é™¤å¤–
    const { password_hash, ...safeProfile } = updatedProfile;
    
    return createSuccessResponse({
      user: safeProfile,
      message: 'Profile updated successfully'
    });
    
  } catch (error) {
    console.error('User profile update error:', error);
    return createErrorResponse(500, 'INTERNAL_SERVER_ERROR', 'Failed to update user profile');
  }
});
```

---

## ğŸ› ï¸ å…±é€šãƒ¦ãƒ¼ãƒ†ã‚£ãƒªãƒ†ã‚£ã¨ãƒŸãƒ‰ãƒ«ã‚¦ã‚§ã‚¢å®Ÿè£…

### ğŸ“¡ ãƒ¬ã‚¹ãƒãƒ³ã‚¹çµ±ä¸€ãƒ¦ãƒ¼ãƒ†ã‚£ãƒªãƒ†ã‚£

```typescript
// supabase/functions/shared/utils/response.ts
export interface APIResponse<T = any> {
  success: boolean;
  data?: T;
  error?: {
    code: string;
    message: string;
    details?: any;
  };
  meta?: {
    timestamp: string;
    request_id: string;
    version: string;
  };
}

export function createSuccessResponse<T>(data: T, status: number = 200): Response {
  const response: APIResponse<T> = {
    success: true,
    data,
    meta: {
      timestamp: new Date().toISOString(),
      request_id: crypto.randomUUID(),
      version: '1.0.0'
    }
  };
  
  return new Response(JSON.stringify(response), {
    status,
    headers: {
      'Content-Type': 'application/json',
      ...corsHeaders
    }
  });
}

export function createErrorResponse(
  status: number,
  code: string,
  message: string,
  details?: any
): Response {
  const response: APIResponse = {
    success: false,
    error: {
      code,
      message,
      details
    },
    meta: {
      timestamp: new Date().toISOString(),
      request_id: crypto.randomUUID(),
      version: '1.0.0'
    }
  };
  
  return new Response(JSON.stringify(response), {
    status,
    headers: {
      'Content-Type': 'application/json',
      ...corsHeaders
    }
  });
}
```

### ğŸ” ãƒãƒªãƒ‡ãƒ¼ã‚·ãƒ§ãƒ³ãƒŸãƒ‰ãƒ«ã‚¦ã‚§ã‚¢

```typescript
// supabase/functions/shared/middleware/validation.ts
import { z } from 'https://deno.land/x/zod@v3.22.4/mod.ts';
import { createErrorResponse } from '../utils/response.ts';

export function validateRequest<T>(schema: z.ZodSchema<T>, data: any): T | Response {
  try {
    return schema.parse(data);
  } catch (error) {
    if (error instanceof z.ZodError) {
      const validationErrors = error.errors.map(err => ({
        field: err.path.join('.'),
        message: err.message,
        code: err.code
      }));
      
      return createErrorResponse(400, 'VALIDATION_ERROR', 'Request validation failed', {
        errors: validationErrors
      });
    }
    
    return createErrorResponse(400, 'INVALID_REQUEST', 'Invalid request format');
  }
}

export function validateQueryParams<T>(schema: z.ZodSchema<T>, url: URL): T | Response {
  const params = Object.fromEntries(url.searchParams.entries());
  return validateRequest(schema, params);
}
```

### ğŸ—„ï¸ ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹ã‚µãƒ¼ãƒ“ã‚¹

```typescript
// supabase/functions/shared/utils/database.ts
import { createClient } from 'https://esm.sh/@supabase/supabase-js@2';

export class DatabaseService {
  private supabase;
  
  constructor() {
    this.supabase = createClient(
      Deno.env.get('SUPABASE_URL')!,
      Deno.env.get('SUPABASE_SERVICE_ROLE_KEY')!
    );
  }
  
  // ç‰©ä»¶é–¢é€£ãƒ¡ã‚½ãƒƒãƒ‰
  async createProperty(userId: string, propertyData: any) {
    const { data, error } = await this.supabase
      .from('properties')
      .insert({
        ...propertyData,
        user_id: userId,
        created_at: new Date().toISOString(),
        updated_at: new Date().toISOString()
      })
      .select()
      .single();
    
    if (error) throw error;
    return data;
  }
  
  async getProperty(userId: string, propertyId: string) {
    const { data, error } = await this.supabase
      .from('properties')
      .select('*')
      .eq('id', propertyId)
      .eq('user_id', userId)
      .single();
    
    if (error && error.code !== 'PGRST116') throw error;
    return data;
  }
  
  async getProperties(userId: string) {
    const { data, error } = await this.supabase
      .from('properties')
      .select('*')
      .eq('user_id', userId)
      .order('created_at', { ascending: false });
    
    if (error) throw error;
    return data || [];
  }
  
  async updateProperty(userId: string, propertyId: string, updateData: any) {
    const { data, error } = await this.supabase
      .from('properties')
      .update({
        ...updateData,
        updated_at: new Date().toISOString()
      })
      .eq('id', propertyId)
      .eq('user_id', userId)
      .select()
      .single();
    
    if (error) throw error;
    return data;
  }
  
  async deleteProperty(userId: string, propertyId: string) {
    const { error } = await this.supabase
      .from('properties')
      .delete()
      .eq('id', propertyId)
      .eq('user_id', userId);
    
    if (error) throw error;
  }
  
  async searchProperties(userId: string, criteria: any) {
    let query = this.supabase
      .from('properties')
      .select('*', { count: 'exact' })
      .eq('user_id', userId);
    
    // æ¤œç´¢æ¡ä»¶ã®é©ç”¨
    if (criteria.query) {
      query = query.or(`name.ilike.%${criteria.query}%,address.ilike.%${criteria.query}%`);
    }
    
    if (criteria.property_type) {
      query = query.eq('property_type', criteria.property_type);
    }
    
    if (criteria.status) {
      query = query.eq('status', criteria.status);
    }
    
    if (criteria.min_price) {
      query = query.gte('purchase_price', criteria.min_price);
    }
    
    if (criteria.max_price) {
      query = query.lte('purchase_price', criteria.max_price);
    }
    
    // ã‚½ãƒ¼ãƒˆ
    query = query.order(criteria.sort_by, { ascending: criteria.sort_order === 'asc' });
    
    // ãƒšãƒ¼ã‚¸ãƒãƒ¼ã‚·ãƒ§ãƒ³
    const offset = (criteria.page - 1) * criteria.limit;
    query = query.range(offset, offset + criteria.limit - 1);
    
    const { data, error, count } = await query;
    
    if (error) throw error;
    
    return {
      properties: data || [],
      total: count || 0
    };
  }
  
  // å€Ÿå…¥é–¢é€£ãƒ¡ã‚½ãƒƒãƒ‰
  async createLoan(userId: string, loanData: any) {
    const { data, error } = await this.supabase
      .from('loans')
      .insert({
        ...loanData,
        user_id: userId,
        created_at: new Date().toISOString(),
        updated_at: new Date().toISOString()
      })
      .select()
      .single();
    
    if (error) throw error;
    return data;
  }
  
  // ãƒ¬ãƒ³ãƒˆãƒ­ãƒ¼ãƒ«é–¢é€£ãƒ¡ã‚½ãƒƒãƒ‰
  async createRentRoll(userId: string, rentRollData: any) {
    const { data, error } = await this.supabase
      .from('rent_rolls')
      .insert({
        ...rentRollData,
        user_id: userId,
        created_at: new Date().toISOString(),
        updated_at: new Date().toISOString()
      })
      .select()
      .single();
    
    if (error) throw error;
    return data;
  }
  
  async getRentRollByUnit(propertyId: string, unitNumber: string) {
    const { data, error } = await this.supabase
      .from('rent_rolls')
      .select('*')
      .eq('property_id', propertyId)
      .eq('unit_number', unitNumber)
      .single();
    
    if (error && error.code !== 'PGRST116') throw error;
    return data;
  }
  
  // ãƒ¦ãƒ¼ã‚¶ãƒ¼é–¢é€£ãƒ¡ã‚½ãƒƒãƒ‰
  async getUserProfile(userId: string) {
    const { data, error } = await this.supabase
      .from('users')
      .select('*')
      .eq('id', userId)
      .single();
    
    if (error) throw error;
    return data;
  }
  
  async updateUserProfile(userId: string, updateData: any) {
    const { data, error } = await this.supabase
      .from('users')
      .update({
        ...updateData,
        updated_at: new Date().toISOString()
      })
      .eq('id', userId)
      .select()
      .single();
    
    if (error) throw error;
    return data;
  }
}
```

